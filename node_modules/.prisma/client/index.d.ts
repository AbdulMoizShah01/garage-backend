
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model WorkOrder
 * 
 */
export type WorkOrder = $Result.DefaultSelection<Prisma.$WorkOrderPayload>
/**
 * Model WorkOrderLineItem
 * 
 */
export type WorkOrderLineItem = $Result.DefaultSelection<Prisma.$WorkOrderLineItemPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model ServiceItem
 * 
 */
export type ServiceItem = $Result.DefaultSelection<Prisma.$ServiceItemPayload>
/**
 * Model WorkOrderLog
 * 
 */
export type WorkOrderLog = $Result.DefaultSelection<Prisma.$WorkOrderLogPayload>
/**
 * Model Worker
 * 
 */
export type Worker = $Result.DefaultSelection<Prisma.$WorkerPayload>
/**
 * Model WorkOrderAssignment
 * 
 */
export type WorkOrderAssignment = $Result.DefaultSelection<Prisma.$WorkOrderAssignmentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs>;

  /**
   * `prisma.workOrder`: Exposes CRUD operations for the **WorkOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkOrders
    * const workOrders = await prisma.workOrder.findMany()
    * ```
    */
  get workOrder(): Prisma.WorkOrderDelegate<ExtArgs>;

  /**
   * `prisma.workOrderLineItem`: Exposes CRUD operations for the **WorkOrderLineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkOrderLineItems
    * const workOrderLineItems = await prisma.workOrderLineItem.findMany()
    * ```
    */
  get workOrderLineItem(): Prisma.WorkOrderLineItemDelegate<ExtArgs>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs>;

  /**
   * `prisma.serviceItem`: Exposes CRUD operations for the **ServiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceItems
    * const serviceItems = await prisma.serviceItem.findMany()
    * ```
    */
  get serviceItem(): Prisma.ServiceItemDelegate<ExtArgs>;

  /**
   * `prisma.workOrderLog`: Exposes CRUD operations for the **WorkOrderLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkOrderLogs
    * const workOrderLogs = await prisma.workOrderLog.findMany()
    * ```
    */
  get workOrderLog(): Prisma.WorkOrderLogDelegate<ExtArgs>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **Worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.WorkerDelegate<ExtArgs>;

  /**
   * `prisma.workOrderAssignment`: Exposes CRUD operations for the **WorkOrderAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkOrderAssignments
    * const workOrderAssignments = await prisma.workOrderAssignment.findMany()
    * ```
    */
  get workOrderAssignment(): Prisma.WorkOrderAssignmentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    Vehicle: 'Vehicle',
    WorkOrder: 'WorkOrder',
    WorkOrderLineItem: 'WorkOrderLineItem',
    InventoryItem: 'InventoryItem',
    ServiceItem: 'ServiceItem',
    WorkOrderLog: 'WorkOrderLog',
    Worker: 'Worker',
    WorkOrderAssignment: 'WorkOrderAssignment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "customer" | "vehicle" | "workOrder" | "workOrderLineItem" | "inventoryItem" | "serviceItem" | "workOrderLog" | "worker" | "workOrderAssignment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      WorkOrder: {
        payload: Prisma.$WorkOrderPayload<ExtArgs>
        fields: Prisma.WorkOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          findFirst: {
            args: Prisma.WorkOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          findMany: {
            args: Prisma.WorkOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          create: {
            args: Prisma.WorkOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          createMany: {
            args: Prisma.WorkOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          delete: {
            args: Prisma.WorkOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          update: {
            args: Prisma.WorkOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          deleteMany: {
            args: Prisma.WorkOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          aggregate: {
            args: Prisma.WorkOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkOrder>
          }
          groupBy: {
            args: Prisma.WorkOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkOrderCountArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderCountAggregateOutputType> | number
          }
        }
      }
      WorkOrderLineItem: {
        payload: Prisma.$WorkOrderLineItemPayload<ExtArgs>
        fields: Prisma.WorkOrderLineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkOrderLineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkOrderLineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload>
          }
          findFirst: {
            args: Prisma.WorkOrderLineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkOrderLineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload>
          }
          findMany: {
            args: Prisma.WorkOrderLineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload>[]
          }
          create: {
            args: Prisma.WorkOrderLineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload>
          }
          createMany: {
            args: Prisma.WorkOrderLineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkOrderLineItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload>[]
          }
          delete: {
            args: Prisma.WorkOrderLineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload>
          }
          update: {
            args: Prisma.WorkOrderLineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload>
          }
          deleteMany: {
            args: Prisma.WorkOrderLineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkOrderLineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkOrderLineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLineItemPayload>
          }
          aggregate: {
            args: Prisma.WorkOrderLineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkOrderLineItem>
          }
          groupBy: {
            args: Prisma.WorkOrderLineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderLineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkOrderLineItemCountArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderLineItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      ServiceItem: {
        payload: Prisma.$ServiceItemPayload<ExtArgs>
        fields: Prisma.ServiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          findFirst: {
            args: Prisma.ServiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          findMany: {
            args: Prisma.ServiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>[]
          }
          create: {
            args: Prisma.ServiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          createMany: {
            args: Prisma.ServiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>[]
          }
          delete: {
            args: Prisma.ServiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          update: {
            args: Prisma.ServiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          deleteMany: {
            args: Prisma.ServiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          aggregate: {
            args: Prisma.ServiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceItem>
          }
          groupBy: {
            args: Prisma.ServiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceItemCountAggregateOutputType> | number
          }
        }
      }
      WorkOrderLog: {
        payload: Prisma.$WorkOrderLogPayload<ExtArgs>
        fields: Prisma.WorkOrderLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkOrderLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkOrderLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload>
          }
          findFirst: {
            args: Prisma.WorkOrderLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkOrderLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload>
          }
          findMany: {
            args: Prisma.WorkOrderLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload>[]
          }
          create: {
            args: Prisma.WorkOrderLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload>
          }
          createMany: {
            args: Prisma.WorkOrderLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkOrderLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload>[]
          }
          delete: {
            args: Prisma.WorkOrderLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload>
          }
          update: {
            args: Prisma.WorkOrderLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload>
          }
          deleteMany: {
            args: Prisma.WorkOrderLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkOrderLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkOrderLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderLogPayload>
          }
          aggregate: {
            args: Prisma.WorkOrderLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkOrderLog>
          }
          groupBy: {
            args: Prisma.WorkOrderLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkOrderLogCountArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderLogCountAggregateOutputType> | number
          }
        }
      }
      Worker: {
        payload: Prisma.$WorkerPayload<ExtArgs>
        fields: Prisma.WorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findFirst: {
            args: Prisma.WorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findMany: {
            args: Prisma.WorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          create: {
            args: Prisma.WorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          createMany: {
            args: Prisma.WorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          delete: {
            args: Prisma.WorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          update: {
            args: Prisma.WorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          deleteMany: {
            args: Prisma.WorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          aggregate: {
            args: Prisma.WorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorker>
          }
          groupBy: {
            args: Prisma.WorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerCountAggregateOutputType> | number
          }
        }
      }
      WorkOrderAssignment: {
        payload: Prisma.$WorkOrderAssignmentPayload<ExtArgs>
        fields: Prisma.WorkOrderAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkOrderAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkOrderAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload>
          }
          findFirst: {
            args: Prisma.WorkOrderAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkOrderAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload>
          }
          findMany: {
            args: Prisma.WorkOrderAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload>[]
          }
          create: {
            args: Prisma.WorkOrderAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload>
          }
          createMany: {
            args: Prisma.WorkOrderAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkOrderAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload>[]
          }
          delete: {
            args: Prisma.WorkOrderAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload>
          }
          update: {
            args: Prisma.WorkOrderAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.WorkOrderAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkOrderAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkOrderAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderAssignmentPayload>
          }
          aggregate: {
            args: Prisma.WorkOrderAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkOrderAssignment>
          }
          groupBy: {
            args: Prisma.WorkOrderAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkOrderAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderAssignmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    vehicles: number
    workOrders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | CustomerCountOutputTypeCountVehiclesArgs
    workOrders?: boolean | CustomerCountOutputTypeCountWorkOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountWorkOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    workOrders: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrders?: boolean | VehicleCountOutputTypeCountWorkOrdersArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountWorkOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
  }


  /**
   * Count Type WorkOrderCountOutputType
   */

  export type WorkOrderCountOutputType = {
    lineItems: number
    logs: number
    assignments: number
  }

  export type WorkOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | WorkOrderCountOutputTypeCountLineItemsArgs
    logs?: boolean | WorkOrderCountOutputTypeCountLogsArgs
    assignments?: boolean | WorkOrderCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * WorkOrderCountOutputType without action
   */
  export type WorkOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderCountOutputType
     */
    select?: WorkOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkOrderCountOutputType without action
   */
  export type WorkOrderCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderLineItemWhereInput
  }

  /**
   * WorkOrderCountOutputType without action
   */
  export type WorkOrderCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderLogWhereInput
  }

  /**
   * WorkOrderCountOutputType without action
   */
  export type WorkOrderCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderAssignmentWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    lineItems: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | InventoryItemCountOutputTypeCountLineItemsArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderLineItemWhereInput
  }


  /**
   * Count Type ServiceItemCountOutputType
   */

  export type ServiceItemCountOutputType = {
    lineItems: number
  }

  export type ServiceItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | ServiceItemCountOutputTypeCountLineItemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceItemCountOutputType without action
   */
  export type ServiceItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItemCountOutputType
     */
    select?: ServiceItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceItemCountOutputType without action
   */
  export type ServiceItemCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderLineItemWhereInput
  }


  /**
   * Count Type WorkerCountOutputType
   */

  export type WorkerCountOutputType = {
    assignments: number
  }

  export type WorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | WorkerCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerCountOutputType
     */
    select?: WorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderAssignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    company: string | null
    notes: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    company: string | null
    notes: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    firstName: number
    lastName: number
    email: number
    phone: number
    company: number
    notes: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    company?: true
    notes?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    company?: true
    notes?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    company?: true
    notes?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    firstName: string
    lastName: string
    email: string | null
    phone: string
    company: string | null
    notes: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    notes?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    vehicles?: boolean | Customer$vehiclesArgs<ExtArgs>
    workOrders?: boolean | Customer$workOrdersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    notes?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    notes?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | Customer$vehiclesArgs<ExtArgs>
    workOrders?: boolean | Customer$workOrdersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
      workOrders: Prisma.$WorkOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      firstName: string
      lastName: string
      email: string | null
      phone: string
      company: string | null
      notes: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      postalCode: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicles<T extends Customer$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany"> | Null>
    workOrders<T extends Customer$workOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$workOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly firstName: FieldRef<"Customer", 'String'>
    readonly lastName: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly company: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly addressLine1: FieldRef<"Customer", 'String'>
    readonly addressLine2: FieldRef<"Customer", 'String'>
    readonly city: FieldRef<"Customer", 'String'>
    readonly state: FieldRef<"Customer", 'String'>
    readonly postalCode: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.vehicles
   */
  export type Customer$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Customer.workOrders
   */
  export type Customer$workOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    cursor?: WorkOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    year: number | null
    mileage: number | null
  }

  export type VehicleSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    year: number | null
    mileage: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: number | null
    vin: string | null
    make: string | null
    model: string | null
    year: number | null
    licensePlate: string | null
    mileage: number | null
    color: string | null
    engine: string | null
    notes: string | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: number | null
    vin: string | null
    make: string | null
    model: string | null
    year: number | null
    licensePlate: string | null
    mileage: number | null
    color: string | null
    engine: string | null
    notes: string | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    customerId: number
    vin: number
    make: number
    model: number
    year: number
    licensePlate: number
    mileage: number
    color: number
    engine: number
    notes: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    id?: true
    customerId?: true
    year?: true
    mileage?: true
  }

  export type VehicleSumAggregateInputType = {
    id?: true
    customerId?: true
    year?: true
    mileage?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    vin?: true
    make?: true
    model?: true
    year?: true
    licensePlate?: true
    mileage?: true
    color?: true
    engine?: true
    notes?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    vin?: true
    make?: true
    model?: true
    year?: true
    licensePlate?: true
    mileage?: true
    color?: true
    engine?: true
    notes?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    vin?: true
    make?: true
    model?: true
    year?: true
    licensePlate?: true
    mileage?: true
    color?: true
    engine?: true
    notes?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    customerId: number
    vin: string
    make: string
    model: string
    year: number
    licensePlate: string | null
    mileage: number | null
    color: string | null
    engine: string | null
    notes: string | null
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    vin?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    licensePlate?: boolean
    mileage?: boolean
    color?: boolean
    engine?: boolean
    notes?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    workOrders?: boolean | Vehicle$workOrdersArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    vin?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    licensePlate?: boolean
    mileage?: boolean
    color?: boolean
    engine?: boolean
    notes?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    vin?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    licensePlate?: boolean
    mileage?: boolean
    color?: boolean
    engine?: boolean
    notes?: boolean
  }

  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    workOrders?: boolean | Vehicle$workOrdersArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      workOrders: Prisma.$WorkOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      customerId: number
      vin: string
      make: string
      model: string
      year: number
      licensePlate: string | null
      mileage: number | null
      color: string | null
      engine: string | null
      notes: string | null
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workOrders<T extends Vehicle$workOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$workOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */ 
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'Int'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Vehicle", 'DateTime'>
    readonly customerId: FieldRef<"Vehicle", 'Int'>
    readonly vin: FieldRef<"Vehicle", 'String'>
    readonly make: FieldRef<"Vehicle", 'String'>
    readonly model: FieldRef<"Vehicle", 'String'>
    readonly year: FieldRef<"Vehicle", 'Int'>
    readonly licensePlate: FieldRef<"Vehicle", 'String'>
    readonly mileage: FieldRef<"Vehicle", 'Int'>
    readonly color: FieldRef<"Vehicle", 'String'>
    readonly engine: FieldRef<"Vehicle", 'String'>
    readonly notes: FieldRef<"Vehicle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle.workOrders
   */
  export type Vehicle$workOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    cursor?: WorkOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model WorkOrder
   */

  export type AggregateWorkOrder = {
    _count: WorkOrderCountAggregateOutputType | null
    _avg: WorkOrderAvgAggregateOutputType | null
    _sum: WorkOrderSumAggregateOutputType | null
    _min: WorkOrderMinAggregateOutputType | null
    _max: WorkOrderMaxAggregateOutputType | null
  }

  export type WorkOrderAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    vehicleId: number | null
    laborCost: Decimal | null
    partsCost: Decimal | null
    taxes: Decimal | null
    discount: Decimal | null
    totalCost: Decimal | null
    parkingCharge: Decimal | null
  }

  export type WorkOrderSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    vehicleId: number | null
    laborCost: Decimal | null
    partsCost: Decimal | null
    taxes: Decimal | null
    discount: Decimal | null
    totalCost: Decimal | null
    parkingCharge: Decimal | null
  }

  export type WorkOrderMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    customerId: number | null
    vehicleId: number | null
    status: string | null
    description: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    laborCost: Decimal | null
    partsCost: Decimal | null
    taxes: Decimal | null
    discount: Decimal | null
    totalCost: Decimal | null
    notes: string | null
    parkingCharge: Decimal | null
    arrivalDate: Date | null
    quotedAt: Date | null
    isHistorical: boolean | null
  }

  export type WorkOrderMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    customerId: number | null
    vehicleId: number | null
    status: string | null
    description: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    laborCost: Decimal | null
    partsCost: Decimal | null
    taxes: Decimal | null
    discount: Decimal | null
    totalCost: Decimal | null
    notes: string | null
    parkingCharge: Decimal | null
    arrivalDate: Date | null
    quotedAt: Date | null
    isHistorical: boolean | null
  }

  export type WorkOrderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    code: number
    customerId: number
    vehicleId: number
    status: number
    description: number
    scheduledDate: number
    completedDate: number
    laborCost: number
    partsCost: number
    taxes: number
    discount: number
    totalCost: number
    notes: number
    parkingCharge: number
    arrivalDate: number
    quotedAt: number
    isHistorical: number
    _all: number
  }


  export type WorkOrderAvgAggregateInputType = {
    id?: true
    customerId?: true
    vehicleId?: true
    laborCost?: true
    partsCost?: true
    taxes?: true
    discount?: true
    totalCost?: true
    parkingCharge?: true
  }

  export type WorkOrderSumAggregateInputType = {
    id?: true
    customerId?: true
    vehicleId?: true
    laborCost?: true
    partsCost?: true
    taxes?: true
    discount?: true
    totalCost?: true
    parkingCharge?: true
  }

  export type WorkOrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    customerId?: true
    vehicleId?: true
    status?: true
    description?: true
    scheduledDate?: true
    completedDate?: true
    laborCost?: true
    partsCost?: true
    taxes?: true
    discount?: true
    totalCost?: true
    notes?: true
    parkingCharge?: true
    arrivalDate?: true
    quotedAt?: true
    isHistorical?: true
  }

  export type WorkOrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    customerId?: true
    vehicleId?: true
    status?: true
    description?: true
    scheduledDate?: true
    completedDate?: true
    laborCost?: true
    partsCost?: true
    taxes?: true
    discount?: true
    totalCost?: true
    notes?: true
    parkingCharge?: true
    arrivalDate?: true
    quotedAt?: true
    isHistorical?: true
  }

  export type WorkOrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    customerId?: true
    vehicleId?: true
    status?: true
    description?: true
    scheduledDate?: true
    completedDate?: true
    laborCost?: true
    partsCost?: true
    taxes?: true
    discount?: true
    totalCost?: true
    notes?: true
    parkingCharge?: true
    arrivalDate?: true
    quotedAt?: true
    isHistorical?: true
    _all?: true
  }

  export type WorkOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrder to aggregate.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkOrders
    **/
    _count?: true | WorkOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkOrderMaxAggregateInputType
  }

  export type GetWorkOrderAggregateType<T extends WorkOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkOrder[P]>
      : GetScalarType<T[P], AggregateWorkOrder[P]>
  }




  export type WorkOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithAggregationInput | WorkOrderOrderByWithAggregationInput[]
    by: WorkOrderScalarFieldEnum[] | WorkOrderScalarFieldEnum
    having?: WorkOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkOrderCountAggregateInputType | true
    _avg?: WorkOrderAvgAggregateInputType
    _sum?: WorkOrderSumAggregateInputType
    _min?: WorkOrderMinAggregateInputType
    _max?: WorkOrderMaxAggregateInputType
  }

  export type WorkOrderGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    code: string
    customerId: number | null
    vehicleId: number
    status: string
    description: string
    scheduledDate: Date | null
    completedDate: Date | null
    laborCost: Decimal
    partsCost: Decimal
    taxes: Decimal
    discount: Decimal
    totalCost: Decimal
    notes: string | null
    parkingCharge: Decimal
    arrivalDate: Date | null
    quotedAt: Date | null
    isHistorical: boolean
    _count: WorkOrderCountAggregateOutputType | null
    _avg: WorkOrderAvgAggregateOutputType | null
    _sum: WorkOrderSumAggregateOutputType | null
    _min: WorkOrderMinAggregateOutputType | null
    _max: WorkOrderMaxAggregateOutputType | null
  }

  type GetWorkOrderGroupByPayload<T extends WorkOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkOrderGroupByOutputType[P]>
            : GetScalarType<T[P], WorkOrderGroupByOutputType[P]>
        }
      >
    >


  export type WorkOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    customerId?: boolean
    vehicleId?: boolean
    status?: boolean
    description?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    laborCost?: boolean
    partsCost?: boolean
    taxes?: boolean
    discount?: boolean
    totalCost?: boolean
    notes?: boolean
    parkingCharge?: boolean
    arrivalDate?: boolean
    quotedAt?: boolean
    isHistorical?: boolean
    customer?: boolean | WorkOrder$customerArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    lineItems?: boolean | WorkOrder$lineItemsArgs<ExtArgs>
    logs?: boolean | WorkOrder$logsArgs<ExtArgs>
    assignments?: boolean | WorkOrder$assignmentsArgs<ExtArgs>
    _count?: boolean | WorkOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    customerId?: boolean
    vehicleId?: boolean
    status?: boolean
    description?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    laborCost?: boolean
    partsCost?: boolean
    taxes?: boolean
    discount?: boolean
    totalCost?: boolean
    notes?: boolean
    parkingCharge?: boolean
    arrivalDate?: boolean
    quotedAt?: boolean
    isHistorical?: boolean
    customer?: boolean | WorkOrder$customerArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    customerId?: boolean
    vehicleId?: boolean
    status?: boolean
    description?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    laborCost?: boolean
    partsCost?: boolean
    taxes?: boolean
    discount?: boolean
    totalCost?: boolean
    notes?: boolean
    parkingCharge?: boolean
    arrivalDate?: boolean
    quotedAt?: boolean
    isHistorical?: boolean
  }

  export type WorkOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | WorkOrder$customerArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    lineItems?: boolean | WorkOrder$lineItemsArgs<ExtArgs>
    logs?: boolean | WorkOrder$logsArgs<ExtArgs>
    assignments?: boolean | WorkOrder$assignmentsArgs<ExtArgs>
    _count?: boolean | WorkOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | WorkOrder$customerArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $WorkOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkOrder"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      lineItems: Prisma.$WorkOrderLineItemPayload<ExtArgs>[]
      logs: Prisma.$WorkOrderLogPayload<ExtArgs>[]
      assignments: Prisma.$WorkOrderAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      code: string
      customerId: number | null
      vehicleId: number
      status: string
      description: string
      scheduledDate: Date | null
      completedDate: Date | null
      laborCost: Prisma.Decimal
      partsCost: Prisma.Decimal
      taxes: Prisma.Decimal
      discount: Prisma.Decimal
      totalCost: Prisma.Decimal
      notes: string | null
      parkingCharge: Prisma.Decimal
      arrivalDate: Date | null
      quotedAt: Date | null
      isHistorical: boolean
    }, ExtArgs["result"]["workOrder"]>
    composites: {}
  }

  type WorkOrderGetPayload<S extends boolean | null | undefined | WorkOrderDefaultArgs> = $Result.GetResult<Prisma.$WorkOrderPayload, S>

  type WorkOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkOrderCountAggregateInputType | true
    }

  export interface WorkOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkOrder'], meta: { name: 'WorkOrder' } }
    /**
     * Find zero or one WorkOrder that matches the filter.
     * @param {WorkOrderFindUniqueArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkOrderFindUniqueArgs>(args: SelectSubset<T, WorkOrderFindUniqueArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkOrderFindUniqueOrThrowArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindFirstArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkOrderFindFirstArgs>(args?: SelectSubset<T, WorkOrderFindFirstArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindFirstOrThrowArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkOrders
     * const workOrders = await prisma.workOrder.findMany()
     * 
     * // Get first 10 WorkOrders
     * const workOrders = await prisma.workOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkOrderFindManyArgs>(args?: SelectSubset<T, WorkOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkOrder.
     * @param {WorkOrderCreateArgs} args - Arguments to create a WorkOrder.
     * @example
     * // Create one WorkOrder
     * const WorkOrder = await prisma.workOrder.create({
     *   data: {
     *     // ... data to create a WorkOrder
     *   }
     * })
     * 
     */
    create<T extends WorkOrderCreateArgs>(args: SelectSubset<T, WorkOrderCreateArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkOrders.
     * @param {WorkOrderCreateManyArgs} args - Arguments to create many WorkOrders.
     * @example
     * // Create many WorkOrders
     * const workOrder = await prisma.workOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkOrderCreateManyArgs>(args?: SelectSubset<T, WorkOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkOrders and returns the data saved in the database.
     * @param {WorkOrderCreateManyAndReturnArgs} args - Arguments to create many WorkOrders.
     * @example
     * // Create many WorkOrders
     * const workOrder = await prisma.workOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkOrders and only return the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkOrder.
     * @param {WorkOrderDeleteArgs} args - Arguments to delete one WorkOrder.
     * @example
     * // Delete one WorkOrder
     * const WorkOrder = await prisma.workOrder.delete({
     *   where: {
     *     // ... filter to delete one WorkOrder
     *   }
     * })
     * 
     */
    delete<T extends WorkOrderDeleteArgs>(args: SelectSubset<T, WorkOrderDeleteArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkOrder.
     * @param {WorkOrderUpdateArgs} args - Arguments to update one WorkOrder.
     * @example
     * // Update one WorkOrder
     * const workOrder = await prisma.workOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkOrderUpdateArgs>(args: SelectSubset<T, WorkOrderUpdateArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkOrders.
     * @param {WorkOrderDeleteManyArgs} args - Arguments to filter WorkOrders to delete.
     * @example
     * // Delete a few WorkOrders
     * const { count } = await prisma.workOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkOrderDeleteManyArgs>(args?: SelectSubset<T, WorkOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkOrders
     * const workOrder = await prisma.workOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkOrderUpdateManyArgs>(args: SelectSubset<T, WorkOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkOrder.
     * @param {WorkOrderUpsertArgs} args - Arguments to update or create a WorkOrder.
     * @example
     * // Update or create a WorkOrder
     * const workOrder = await prisma.workOrder.upsert({
     *   create: {
     *     // ... data to create a WorkOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkOrder we want to update
     *   }
     * })
     */
    upsert<T extends WorkOrderUpsertArgs>(args: SelectSubset<T, WorkOrderUpsertArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderCountArgs} args - Arguments to filter WorkOrders to count.
     * @example
     * // Count the number of WorkOrders
     * const count = await prisma.workOrder.count({
     *   where: {
     *     // ... the filter for the WorkOrders we want to count
     *   }
     * })
    **/
    count<T extends WorkOrderCountArgs>(
      args?: Subset<T, WorkOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkOrderAggregateArgs>(args: Subset<T, WorkOrderAggregateArgs>): Prisma.PrismaPromise<GetWorkOrderAggregateType<T>>

    /**
     * Group by WorkOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkOrderGroupByArgs['orderBy'] }
        : { orderBy?: WorkOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkOrder model
   */
  readonly fields: WorkOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends WorkOrder$customerArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrder$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lineItems<T extends WorkOrder$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrder$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends WorkOrder$logsArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrder$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends WorkOrder$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrder$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkOrder model
   */ 
  interface WorkOrderFieldRefs {
    readonly id: FieldRef<"WorkOrder", 'Int'>
    readonly createdAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly code: FieldRef<"WorkOrder", 'String'>
    readonly customerId: FieldRef<"WorkOrder", 'Int'>
    readonly vehicleId: FieldRef<"WorkOrder", 'Int'>
    readonly status: FieldRef<"WorkOrder", 'String'>
    readonly description: FieldRef<"WorkOrder", 'String'>
    readonly scheduledDate: FieldRef<"WorkOrder", 'DateTime'>
    readonly completedDate: FieldRef<"WorkOrder", 'DateTime'>
    readonly laborCost: FieldRef<"WorkOrder", 'Decimal'>
    readonly partsCost: FieldRef<"WorkOrder", 'Decimal'>
    readonly taxes: FieldRef<"WorkOrder", 'Decimal'>
    readonly discount: FieldRef<"WorkOrder", 'Decimal'>
    readonly totalCost: FieldRef<"WorkOrder", 'Decimal'>
    readonly notes: FieldRef<"WorkOrder", 'String'>
    readonly parkingCharge: FieldRef<"WorkOrder", 'Decimal'>
    readonly arrivalDate: FieldRef<"WorkOrder", 'DateTime'>
    readonly quotedAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly isHistorical: FieldRef<"WorkOrder", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WorkOrder findUnique
   */
  export type WorkOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder findUniqueOrThrow
   */
  export type WorkOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder findFirst
   */
  export type WorkOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrders.
     */
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder findFirstOrThrow
   */
  export type WorkOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrders.
     */
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder findMany
   */
  export type WorkOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrders to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder create
   */
  export type WorkOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkOrder.
     */
    data: XOR<WorkOrderCreateInput, WorkOrderUncheckedCreateInput>
  }

  /**
   * WorkOrder createMany
   */
  export type WorkOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkOrders.
     */
    data: WorkOrderCreateManyInput | WorkOrderCreateManyInput[]
  }

  /**
   * WorkOrder createManyAndReturn
   */
  export type WorkOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkOrders.
     */
    data: WorkOrderCreateManyInput | WorkOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkOrder update
   */
  export type WorkOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkOrder.
     */
    data: XOR<WorkOrderUpdateInput, WorkOrderUncheckedUpdateInput>
    /**
     * Choose, which WorkOrder to update.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder updateMany
   */
  export type WorkOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkOrders.
     */
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrders to update
     */
    where?: WorkOrderWhereInput
  }

  /**
   * WorkOrder upsert
   */
  export type WorkOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkOrder to update in case it exists.
     */
    where: WorkOrderWhereUniqueInput
    /**
     * In case the WorkOrder found by the `where` argument doesn't exist, create a new WorkOrder with this data.
     */
    create: XOR<WorkOrderCreateInput, WorkOrderUncheckedCreateInput>
    /**
     * In case the WorkOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkOrderUpdateInput, WorkOrderUncheckedUpdateInput>
  }

  /**
   * WorkOrder delete
   */
  export type WorkOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter which WorkOrder to delete.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder deleteMany
   */
  export type WorkOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrders to delete
     */
    where?: WorkOrderWhereInput
  }

  /**
   * WorkOrder.customer
   */
  export type WorkOrder$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * WorkOrder.lineItems
   */
  export type WorkOrder$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    where?: WorkOrderLineItemWhereInput
    orderBy?: WorkOrderLineItemOrderByWithRelationInput | WorkOrderLineItemOrderByWithRelationInput[]
    cursor?: WorkOrderLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderLineItemScalarFieldEnum | WorkOrderLineItemScalarFieldEnum[]
  }

  /**
   * WorkOrder.logs
   */
  export type WorkOrder$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    where?: WorkOrderLogWhereInput
    orderBy?: WorkOrderLogOrderByWithRelationInput | WorkOrderLogOrderByWithRelationInput[]
    cursor?: WorkOrderLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderLogScalarFieldEnum | WorkOrderLogScalarFieldEnum[]
  }

  /**
   * WorkOrder.assignments
   */
  export type WorkOrder$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    where?: WorkOrderAssignmentWhereInput
    orderBy?: WorkOrderAssignmentOrderByWithRelationInput | WorkOrderAssignmentOrderByWithRelationInput[]
    cursor?: WorkOrderAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderAssignmentScalarFieldEnum | WorkOrderAssignmentScalarFieldEnum[]
  }

  /**
   * WorkOrder without action
   */
  export type WorkOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
  }


  /**
   * Model WorkOrderLineItem
   */

  export type AggregateWorkOrderLineItem = {
    _count: WorkOrderLineItemCountAggregateOutputType | null
    _avg: WorkOrderLineItemAvgAggregateOutputType | null
    _sum: WorkOrderLineItemSumAggregateOutputType | null
    _min: WorkOrderLineItemMinAggregateOutputType | null
    _max: WorkOrderLineItemMaxAggregateOutputType | null
  }

  export type WorkOrderLineItemAvgAggregateOutputType = {
    id: number | null
    workOrderId: number | null
    inventoryItemId: number | null
    serviceItemId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type WorkOrderLineItemSumAggregateOutputType = {
    id: number | null
    workOrderId: number | null
    inventoryItemId: number | null
    serviceItemId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type WorkOrderLineItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    workOrderId: number | null
    inventoryItemId: number | null
    serviceItemId: number | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type WorkOrderLineItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    workOrderId: number | null
    inventoryItemId: number | null
    serviceItemId: number | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type WorkOrderLineItemCountAggregateOutputType = {
    id: number
    createdAt: number
    workOrderId: number
    inventoryItemId: number
    serviceItemId: number
    description: number
    quantity: number
    unitPrice: number
    lineTotal: number
    _all: number
  }


  export type WorkOrderLineItemAvgAggregateInputType = {
    id?: true
    workOrderId?: true
    inventoryItemId?: true
    serviceItemId?: true
    quantity?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type WorkOrderLineItemSumAggregateInputType = {
    id?: true
    workOrderId?: true
    inventoryItemId?: true
    serviceItemId?: true
    quantity?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type WorkOrderLineItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    workOrderId?: true
    inventoryItemId?: true
    serviceItemId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type WorkOrderLineItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    workOrderId?: true
    inventoryItemId?: true
    serviceItemId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type WorkOrderLineItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    workOrderId?: true
    inventoryItemId?: true
    serviceItemId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    lineTotal?: true
    _all?: true
  }

  export type WorkOrderLineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrderLineItem to aggregate.
     */
    where?: WorkOrderLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderLineItems to fetch.
     */
    orderBy?: WorkOrderLineItemOrderByWithRelationInput | WorkOrderLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkOrderLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkOrderLineItems
    **/
    _count?: true | WorkOrderLineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkOrderLineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkOrderLineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkOrderLineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkOrderLineItemMaxAggregateInputType
  }

  export type GetWorkOrderLineItemAggregateType<T extends WorkOrderLineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkOrderLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkOrderLineItem[P]>
      : GetScalarType<T[P], AggregateWorkOrderLineItem[P]>
  }




  export type WorkOrderLineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderLineItemWhereInput
    orderBy?: WorkOrderLineItemOrderByWithAggregationInput | WorkOrderLineItemOrderByWithAggregationInput[]
    by: WorkOrderLineItemScalarFieldEnum[] | WorkOrderLineItemScalarFieldEnum
    having?: WorkOrderLineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkOrderLineItemCountAggregateInputType | true
    _avg?: WorkOrderLineItemAvgAggregateInputType
    _sum?: WorkOrderLineItemSumAggregateInputType
    _min?: WorkOrderLineItemMinAggregateInputType
    _max?: WorkOrderLineItemMaxAggregateInputType
  }

  export type WorkOrderLineItemGroupByOutputType = {
    id: number
    createdAt: Date
    workOrderId: number
    inventoryItemId: number | null
    serviceItemId: number | null
    description: string
    quantity: number
    unitPrice: Decimal
    lineTotal: Decimal
    _count: WorkOrderLineItemCountAggregateOutputType | null
    _avg: WorkOrderLineItemAvgAggregateOutputType | null
    _sum: WorkOrderLineItemSumAggregateOutputType | null
    _min: WorkOrderLineItemMinAggregateOutputType | null
    _max: WorkOrderLineItemMaxAggregateOutputType | null
  }

  type GetWorkOrderLineItemGroupByPayload<T extends WorkOrderLineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkOrderLineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkOrderLineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkOrderLineItemGroupByOutputType[P]>
            : GetScalarType<T[P], WorkOrderLineItemGroupByOutputType[P]>
        }
      >
    >


  export type WorkOrderLineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    workOrderId?: boolean
    inventoryItemId?: boolean
    serviceItemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    inventoryItem?: boolean | WorkOrderLineItem$inventoryItemArgs<ExtArgs>
    serviceItem?: boolean | WorkOrderLineItem$serviceItemArgs<ExtArgs>
  }, ExtArgs["result"]["workOrderLineItem"]>

  export type WorkOrderLineItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    workOrderId?: boolean
    inventoryItemId?: boolean
    serviceItemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    inventoryItem?: boolean | WorkOrderLineItem$inventoryItemArgs<ExtArgs>
    serviceItem?: boolean | WorkOrderLineItem$serviceItemArgs<ExtArgs>
  }, ExtArgs["result"]["workOrderLineItem"]>

  export type WorkOrderLineItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    workOrderId?: boolean
    inventoryItemId?: boolean
    serviceItemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
  }

  export type WorkOrderLineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    inventoryItem?: boolean | WorkOrderLineItem$inventoryItemArgs<ExtArgs>
    serviceItem?: boolean | WorkOrderLineItem$serviceItemArgs<ExtArgs>
  }
  export type WorkOrderLineItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    inventoryItem?: boolean | WorkOrderLineItem$inventoryItemArgs<ExtArgs>
    serviceItem?: boolean | WorkOrderLineItem$serviceItemArgs<ExtArgs>
  }

  export type $WorkOrderLineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkOrderLineItem"
    objects: {
      workOrder: Prisma.$WorkOrderPayload<ExtArgs>
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs> | null
      serviceItem: Prisma.$ServiceItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      workOrderId: number
      inventoryItemId: number | null
      serviceItemId: number | null
      description: string
      quantity: number
      unitPrice: Prisma.Decimal
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["workOrderLineItem"]>
    composites: {}
  }

  type WorkOrderLineItemGetPayload<S extends boolean | null | undefined | WorkOrderLineItemDefaultArgs> = $Result.GetResult<Prisma.$WorkOrderLineItemPayload, S>

  type WorkOrderLineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkOrderLineItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkOrderLineItemCountAggregateInputType | true
    }

  export interface WorkOrderLineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkOrderLineItem'], meta: { name: 'WorkOrderLineItem' } }
    /**
     * Find zero or one WorkOrderLineItem that matches the filter.
     * @param {WorkOrderLineItemFindUniqueArgs} args - Arguments to find a WorkOrderLineItem
     * @example
     * // Get one WorkOrderLineItem
     * const workOrderLineItem = await prisma.workOrderLineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkOrderLineItemFindUniqueArgs>(args: SelectSubset<T, WorkOrderLineItemFindUniqueArgs<ExtArgs>>): Prisma__WorkOrderLineItemClient<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkOrderLineItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkOrderLineItemFindUniqueOrThrowArgs} args - Arguments to find a WorkOrderLineItem
     * @example
     * // Get one WorkOrderLineItem
     * const workOrderLineItem = await prisma.workOrderLineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkOrderLineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkOrderLineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkOrderLineItemClient<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkOrderLineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLineItemFindFirstArgs} args - Arguments to find a WorkOrderLineItem
     * @example
     * // Get one WorkOrderLineItem
     * const workOrderLineItem = await prisma.workOrderLineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkOrderLineItemFindFirstArgs>(args?: SelectSubset<T, WorkOrderLineItemFindFirstArgs<ExtArgs>>): Prisma__WorkOrderLineItemClient<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkOrderLineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLineItemFindFirstOrThrowArgs} args - Arguments to find a WorkOrderLineItem
     * @example
     * // Get one WorkOrderLineItem
     * const workOrderLineItem = await prisma.workOrderLineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkOrderLineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkOrderLineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkOrderLineItemClient<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkOrderLineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkOrderLineItems
     * const workOrderLineItems = await prisma.workOrderLineItem.findMany()
     * 
     * // Get first 10 WorkOrderLineItems
     * const workOrderLineItems = await prisma.workOrderLineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workOrderLineItemWithIdOnly = await prisma.workOrderLineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkOrderLineItemFindManyArgs>(args?: SelectSubset<T, WorkOrderLineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkOrderLineItem.
     * @param {WorkOrderLineItemCreateArgs} args - Arguments to create a WorkOrderLineItem.
     * @example
     * // Create one WorkOrderLineItem
     * const WorkOrderLineItem = await prisma.workOrderLineItem.create({
     *   data: {
     *     // ... data to create a WorkOrderLineItem
     *   }
     * })
     * 
     */
    create<T extends WorkOrderLineItemCreateArgs>(args: SelectSubset<T, WorkOrderLineItemCreateArgs<ExtArgs>>): Prisma__WorkOrderLineItemClient<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkOrderLineItems.
     * @param {WorkOrderLineItemCreateManyArgs} args - Arguments to create many WorkOrderLineItems.
     * @example
     * // Create many WorkOrderLineItems
     * const workOrderLineItem = await prisma.workOrderLineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkOrderLineItemCreateManyArgs>(args?: SelectSubset<T, WorkOrderLineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkOrderLineItems and returns the data saved in the database.
     * @param {WorkOrderLineItemCreateManyAndReturnArgs} args - Arguments to create many WorkOrderLineItems.
     * @example
     * // Create many WorkOrderLineItems
     * const workOrderLineItem = await prisma.workOrderLineItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkOrderLineItems and only return the `id`
     * const workOrderLineItemWithIdOnly = await prisma.workOrderLineItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkOrderLineItemCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkOrderLineItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkOrderLineItem.
     * @param {WorkOrderLineItemDeleteArgs} args - Arguments to delete one WorkOrderLineItem.
     * @example
     * // Delete one WorkOrderLineItem
     * const WorkOrderLineItem = await prisma.workOrderLineItem.delete({
     *   where: {
     *     // ... filter to delete one WorkOrderLineItem
     *   }
     * })
     * 
     */
    delete<T extends WorkOrderLineItemDeleteArgs>(args: SelectSubset<T, WorkOrderLineItemDeleteArgs<ExtArgs>>): Prisma__WorkOrderLineItemClient<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkOrderLineItem.
     * @param {WorkOrderLineItemUpdateArgs} args - Arguments to update one WorkOrderLineItem.
     * @example
     * // Update one WorkOrderLineItem
     * const workOrderLineItem = await prisma.workOrderLineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkOrderLineItemUpdateArgs>(args: SelectSubset<T, WorkOrderLineItemUpdateArgs<ExtArgs>>): Prisma__WorkOrderLineItemClient<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkOrderLineItems.
     * @param {WorkOrderLineItemDeleteManyArgs} args - Arguments to filter WorkOrderLineItems to delete.
     * @example
     * // Delete a few WorkOrderLineItems
     * const { count } = await prisma.workOrderLineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkOrderLineItemDeleteManyArgs>(args?: SelectSubset<T, WorkOrderLineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrderLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkOrderLineItems
     * const workOrderLineItem = await prisma.workOrderLineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkOrderLineItemUpdateManyArgs>(args: SelectSubset<T, WorkOrderLineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkOrderLineItem.
     * @param {WorkOrderLineItemUpsertArgs} args - Arguments to update or create a WorkOrderLineItem.
     * @example
     * // Update or create a WorkOrderLineItem
     * const workOrderLineItem = await prisma.workOrderLineItem.upsert({
     *   create: {
     *     // ... data to create a WorkOrderLineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkOrderLineItem we want to update
     *   }
     * })
     */
    upsert<T extends WorkOrderLineItemUpsertArgs>(args: SelectSubset<T, WorkOrderLineItemUpsertArgs<ExtArgs>>): Prisma__WorkOrderLineItemClient<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkOrderLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLineItemCountArgs} args - Arguments to filter WorkOrderLineItems to count.
     * @example
     * // Count the number of WorkOrderLineItems
     * const count = await prisma.workOrderLineItem.count({
     *   where: {
     *     // ... the filter for the WorkOrderLineItems we want to count
     *   }
     * })
    **/
    count<T extends WorkOrderLineItemCountArgs>(
      args?: Subset<T, WorkOrderLineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkOrderLineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkOrderLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkOrderLineItemAggregateArgs>(args: Subset<T, WorkOrderLineItemAggregateArgs>): Prisma.PrismaPromise<GetWorkOrderLineItemAggregateType<T>>

    /**
     * Group by WorkOrderLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkOrderLineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkOrderLineItemGroupByArgs['orderBy'] }
        : { orderBy?: WorkOrderLineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkOrderLineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkOrderLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkOrderLineItem model
   */
  readonly fields: WorkOrderLineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkOrderLineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkOrderLineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workOrder<T extends WorkOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrderDefaultArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inventoryItem<T extends WorkOrderLineItem$inventoryItemArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrderLineItem$inventoryItemArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    serviceItem<T extends WorkOrderLineItem$serviceItemArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrderLineItem$serviceItemArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkOrderLineItem model
   */ 
  interface WorkOrderLineItemFieldRefs {
    readonly id: FieldRef<"WorkOrderLineItem", 'Int'>
    readonly createdAt: FieldRef<"WorkOrderLineItem", 'DateTime'>
    readonly workOrderId: FieldRef<"WorkOrderLineItem", 'Int'>
    readonly inventoryItemId: FieldRef<"WorkOrderLineItem", 'Int'>
    readonly serviceItemId: FieldRef<"WorkOrderLineItem", 'Int'>
    readonly description: FieldRef<"WorkOrderLineItem", 'String'>
    readonly quantity: FieldRef<"WorkOrderLineItem", 'Int'>
    readonly unitPrice: FieldRef<"WorkOrderLineItem", 'Decimal'>
    readonly lineTotal: FieldRef<"WorkOrderLineItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * WorkOrderLineItem findUnique
   */
  export type WorkOrderLineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLineItem to fetch.
     */
    where: WorkOrderLineItemWhereUniqueInput
  }

  /**
   * WorkOrderLineItem findUniqueOrThrow
   */
  export type WorkOrderLineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLineItem to fetch.
     */
    where: WorkOrderLineItemWhereUniqueInput
  }

  /**
   * WorkOrderLineItem findFirst
   */
  export type WorkOrderLineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLineItem to fetch.
     */
    where?: WorkOrderLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderLineItems to fetch.
     */
    orderBy?: WorkOrderLineItemOrderByWithRelationInput | WorkOrderLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrderLineItems.
     */
    cursor?: WorkOrderLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrderLineItems.
     */
    distinct?: WorkOrderLineItemScalarFieldEnum | WorkOrderLineItemScalarFieldEnum[]
  }

  /**
   * WorkOrderLineItem findFirstOrThrow
   */
  export type WorkOrderLineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLineItem to fetch.
     */
    where?: WorkOrderLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderLineItems to fetch.
     */
    orderBy?: WorkOrderLineItemOrderByWithRelationInput | WorkOrderLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrderLineItems.
     */
    cursor?: WorkOrderLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrderLineItems.
     */
    distinct?: WorkOrderLineItemScalarFieldEnum | WorkOrderLineItemScalarFieldEnum[]
  }

  /**
   * WorkOrderLineItem findMany
   */
  export type WorkOrderLineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLineItems to fetch.
     */
    where?: WorkOrderLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderLineItems to fetch.
     */
    orderBy?: WorkOrderLineItemOrderByWithRelationInput | WorkOrderLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkOrderLineItems.
     */
    cursor?: WorkOrderLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderLineItems.
     */
    skip?: number
    distinct?: WorkOrderLineItemScalarFieldEnum | WorkOrderLineItemScalarFieldEnum[]
  }

  /**
   * WorkOrderLineItem create
   */
  export type WorkOrderLineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkOrderLineItem.
     */
    data: XOR<WorkOrderLineItemCreateInput, WorkOrderLineItemUncheckedCreateInput>
  }

  /**
   * WorkOrderLineItem createMany
   */
  export type WorkOrderLineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkOrderLineItems.
     */
    data: WorkOrderLineItemCreateManyInput | WorkOrderLineItemCreateManyInput[]
  }

  /**
   * WorkOrderLineItem createManyAndReturn
   */
  export type WorkOrderLineItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkOrderLineItems.
     */
    data: WorkOrderLineItemCreateManyInput | WorkOrderLineItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkOrderLineItem update
   */
  export type WorkOrderLineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkOrderLineItem.
     */
    data: XOR<WorkOrderLineItemUpdateInput, WorkOrderLineItemUncheckedUpdateInput>
    /**
     * Choose, which WorkOrderLineItem to update.
     */
    where: WorkOrderLineItemWhereUniqueInput
  }

  /**
   * WorkOrderLineItem updateMany
   */
  export type WorkOrderLineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkOrderLineItems.
     */
    data: XOR<WorkOrderLineItemUpdateManyMutationInput, WorkOrderLineItemUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrderLineItems to update
     */
    where?: WorkOrderLineItemWhereInput
  }

  /**
   * WorkOrderLineItem upsert
   */
  export type WorkOrderLineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkOrderLineItem to update in case it exists.
     */
    where: WorkOrderLineItemWhereUniqueInput
    /**
     * In case the WorkOrderLineItem found by the `where` argument doesn't exist, create a new WorkOrderLineItem with this data.
     */
    create: XOR<WorkOrderLineItemCreateInput, WorkOrderLineItemUncheckedCreateInput>
    /**
     * In case the WorkOrderLineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkOrderLineItemUpdateInput, WorkOrderLineItemUncheckedUpdateInput>
  }

  /**
   * WorkOrderLineItem delete
   */
  export type WorkOrderLineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    /**
     * Filter which WorkOrderLineItem to delete.
     */
    where: WorkOrderLineItemWhereUniqueInput
  }

  /**
   * WorkOrderLineItem deleteMany
   */
  export type WorkOrderLineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrderLineItems to delete
     */
    where?: WorkOrderLineItemWhereInput
  }

  /**
   * WorkOrderLineItem.inventoryItem
   */
  export type WorkOrderLineItem$inventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
  }

  /**
   * WorkOrderLineItem.serviceItem
   */
  export type WorkOrderLineItem$serviceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    where?: ServiceItemWhereInput
  }

  /**
   * WorkOrderLineItem without action
   */
  export type WorkOrderLineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    id: number | null
    quantityOnHand: number | null
    reorderPoint: number | null
    unitCost: Decimal | null
    unitPrice: Decimal | null
  }

  export type InventoryItemSumAggregateOutputType = {
    id: number | null
    quantityOnHand: number | null
    reorderPoint: number | null
    unitCost: Decimal | null
    unitPrice: Decimal | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    sku: string | null
    description: string | null
    quantityOnHand: number | null
    reorderPoint: number | null
    unitCost: Decimal | null
    unitPrice: Decimal | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    sku: string | null
    description: string | null
    quantityOnHand: number | null
    reorderPoint: number | null
    unitCost: Decimal | null
    unitPrice: Decimal | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    sku: number
    description: number
    quantityOnHand: number
    reorderPoint: number
    unitCost: number
    unitPrice: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    id?: true
    quantityOnHand?: true
    reorderPoint?: true
    unitCost?: true
    unitPrice?: true
  }

  export type InventoryItemSumAggregateInputType = {
    id?: true
    quantityOnHand?: true
    reorderPoint?: true
    unitCost?: true
    unitPrice?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    sku?: true
    description?: true
    quantityOnHand?: true
    reorderPoint?: true
    unitCost?: true
    unitPrice?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    sku?: true
    description?: true
    quantityOnHand?: true
    reorderPoint?: true
    unitCost?: true
    unitPrice?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    sku?: true
    description?: true
    quantityOnHand?: true
    reorderPoint?: true
    unitCost?: true
    unitPrice?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    sku: string
    description: string | null
    quantityOnHand: number
    reorderPoint: number
    unitCost: Decimal
    unitPrice: Decimal
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    sku?: boolean
    description?: boolean
    quantityOnHand?: boolean
    reorderPoint?: boolean
    unitCost?: boolean
    unitPrice?: boolean
    lineItems?: boolean | InventoryItem$lineItemsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    sku?: boolean
    description?: boolean
    quantityOnHand?: boolean
    reorderPoint?: boolean
    unitCost?: boolean
    unitPrice?: boolean
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    sku?: boolean
    description?: boolean
    quantityOnHand?: boolean
    reorderPoint?: boolean
    unitCost?: boolean
    unitPrice?: boolean
  }

  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | InventoryItem$lineItemsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      lineItems: Prisma.$WorkOrderLineItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string
      sku: string
      description: string | null
      quantityOnHand: number
      reorderPoint: number
      unitCost: Prisma.Decimal
      unitPrice: Prisma.Decimal
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineItems<T extends InventoryItem$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */ 
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'Int'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly name: FieldRef<"InventoryItem", 'String'>
    readonly sku: FieldRef<"InventoryItem", 'String'>
    readonly description: FieldRef<"InventoryItem", 'String'>
    readonly quantityOnHand: FieldRef<"InventoryItem", 'Int'>
    readonly reorderPoint: FieldRef<"InventoryItem", 'Int'>
    readonly unitCost: FieldRef<"InventoryItem", 'Decimal'>
    readonly unitPrice: FieldRef<"InventoryItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem.lineItems
   */
  export type InventoryItem$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    where?: WorkOrderLineItemWhereInput
    orderBy?: WorkOrderLineItemOrderByWithRelationInput | WorkOrderLineItemOrderByWithRelationInput[]
    cursor?: WorkOrderLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderLineItemScalarFieldEnum | WorkOrderLineItemScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model ServiceItem
   */

  export type AggregateServiceItem = {
    _count: ServiceItemCountAggregateOutputType | null
    _avg: ServiceItemAvgAggregateOutputType | null
    _sum: ServiceItemSumAggregateOutputType | null
    _min: ServiceItemMinAggregateOutputType | null
    _max: ServiceItemMaxAggregateOutputType | null
  }

  export type ServiceItemAvgAggregateOutputType = {
    id: number | null
    defaultPrice: Decimal | null
  }

  export type ServiceItemSumAggregateOutputType = {
    id: number | null
    defaultPrice: Decimal | null
  }

  export type ServiceItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    defaultPrice: Decimal | null
  }

  export type ServiceItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    defaultPrice: Decimal | null
  }

  export type ServiceItemCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    defaultPrice: number
    _all: number
  }


  export type ServiceItemAvgAggregateInputType = {
    id?: true
    defaultPrice?: true
  }

  export type ServiceItemSumAggregateInputType = {
    id?: true
    defaultPrice?: true
  }

  export type ServiceItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    defaultPrice?: true
  }

  export type ServiceItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    defaultPrice?: true
  }

  export type ServiceItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    defaultPrice?: true
    _all?: true
  }

  export type ServiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceItem to aggregate.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceItems
    **/
    _count?: true | ServiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceItemMaxAggregateInputType
  }

  export type GetServiceItemAggregateType<T extends ServiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceItem[P]>
      : GetScalarType<T[P], AggregateServiceItem[P]>
  }




  export type ServiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceItemWhereInput
    orderBy?: ServiceItemOrderByWithAggregationInput | ServiceItemOrderByWithAggregationInput[]
    by: ServiceItemScalarFieldEnum[] | ServiceItemScalarFieldEnum
    having?: ServiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceItemCountAggregateInputType | true
    _avg?: ServiceItemAvgAggregateInputType
    _sum?: ServiceItemSumAggregateInputType
    _min?: ServiceItemMinAggregateInputType
    _max?: ServiceItemMaxAggregateInputType
  }

  export type ServiceItemGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    defaultPrice: Decimal
    _count: ServiceItemCountAggregateOutputType | null
    _avg: ServiceItemAvgAggregateOutputType | null
    _sum: ServiceItemSumAggregateOutputType | null
    _min: ServiceItemMinAggregateOutputType | null
    _max: ServiceItemMaxAggregateOutputType | null
  }

  type GetServiceItemGroupByPayload<T extends ServiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceItemGroupByOutputType[P]>
        }
      >
    >


  export type ServiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    defaultPrice?: boolean
    lineItems?: boolean | ServiceItem$lineItemsArgs<ExtArgs>
    _count?: boolean | ServiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceItem"]>

  export type ServiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    defaultPrice?: boolean
  }, ExtArgs["result"]["serviceItem"]>

  export type ServiceItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    defaultPrice?: boolean
  }

  export type ServiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | ServiceItem$lineItemsArgs<ExtArgs>
    _count?: boolean | ServiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceItem"
    objects: {
      lineItems: Prisma.$WorkOrderLineItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
      defaultPrice: Prisma.Decimal
    }, ExtArgs["result"]["serviceItem"]>
    composites: {}
  }

  type ServiceItemGetPayload<S extends boolean | null | undefined | ServiceItemDefaultArgs> = $Result.GetResult<Prisma.$ServiceItemPayload, S>

  type ServiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceItemCountAggregateInputType | true
    }

  export interface ServiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceItem'], meta: { name: 'ServiceItem' } }
    /**
     * Find zero or one ServiceItem that matches the filter.
     * @param {ServiceItemFindUniqueArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceItemFindUniqueArgs>(args: SelectSubset<T, ServiceItemFindUniqueArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceItemFindUniqueOrThrowArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemFindFirstArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceItemFindFirstArgs>(args?: SelectSubset<T, ServiceItemFindFirstArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemFindFirstOrThrowArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceItems
     * const serviceItems = await prisma.serviceItem.findMany()
     * 
     * // Get first 10 ServiceItems
     * const serviceItems = await prisma.serviceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceItemWithIdOnly = await prisma.serviceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceItemFindManyArgs>(args?: SelectSubset<T, ServiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceItem.
     * @param {ServiceItemCreateArgs} args - Arguments to create a ServiceItem.
     * @example
     * // Create one ServiceItem
     * const ServiceItem = await prisma.serviceItem.create({
     *   data: {
     *     // ... data to create a ServiceItem
     *   }
     * })
     * 
     */
    create<T extends ServiceItemCreateArgs>(args: SelectSubset<T, ServiceItemCreateArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceItems.
     * @param {ServiceItemCreateManyArgs} args - Arguments to create many ServiceItems.
     * @example
     * // Create many ServiceItems
     * const serviceItem = await prisma.serviceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceItemCreateManyArgs>(args?: SelectSubset<T, ServiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceItems and returns the data saved in the database.
     * @param {ServiceItemCreateManyAndReturnArgs} args - Arguments to create many ServiceItems.
     * @example
     * // Create many ServiceItems
     * const serviceItem = await prisma.serviceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceItems and only return the `id`
     * const serviceItemWithIdOnly = await prisma.serviceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceItem.
     * @param {ServiceItemDeleteArgs} args - Arguments to delete one ServiceItem.
     * @example
     * // Delete one ServiceItem
     * const ServiceItem = await prisma.serviceItem.delete({
     *   where: {
     *     // ... filter to delete one ServiceItem
     *   }
     * })
     * 
     */
    delete<T extends ServiceItemDeleteArgs>(args: SelectSubset<T, ServiceItemDeleteArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceItem.
     * @param {ServiceItemUpdateArgs} args - Arguments to update one ServiceItem.
     * @example
     * // Update one ServiceItem
     * const serviceItem = await prisma.serviceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceItemUpdateArgs>(args: SelectSubset<T, ServiceItemUpdateArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceItems.
     * @param {ServiceItemDeleteManyArgs} args - Arguments to filter ServiceItems to delete.
     * @example
     * // Delete a few ServiceItems
     * const { count } = await prisma.serviceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceItemDeleteManyArgs>(args?: SelectSubset<T, ServiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceItems
     * const serviceItem = await prisma.serviceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceItemUpdateManyArgs>(args: SelectSubset<T, ServiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceItem.
     * @param {ServiceItemUpsertArgs} args - Arguments to update or create a ServiceItem.
     * @example
     * // Update or create a ServiceItem
     * const serviceItem = await prisma.serviceItem.upsert({
     *   create: {
     *     // ... data to create a ServiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceItem we want to update
     *   }
     * })
     */
    upsert<T extends ServiceItemUpsertArgs>(args: SelectSubset<T, ServiceItemUpsertArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemCountArgs} args - Arguments to filter ServiceItems to count.
     * @example
     * // Count the number of ServiceItems
     * const count = await prisma.serviceItem.count({
     *   where: {
     *     // ... the filter for the ServiceItems we want to count
     *   }
     * })
    **/
    count<T extends ServiceItemCountArgs>(
      args?: Subset<T, ServiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceItemAggregateArgs>(args: Subset<T, ServiceItemAggregateArgs>): Prisma.PrismaPromise<GetServiceItemAggregateType<T>>

    /**
     * Group by ServiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceItemGroupByArgs['orderBy'] }
        : { orderBy?: ServiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceItem model
   */
  readonly fields: ServiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineItems<T extends ServiceItem$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceItem$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderLineItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceItem model
   */ 
  interface ServiceItemFieldRefs {
    readonly id: FieldRef<"ServiceItem", 'Int'>
    readonly createdAt: FieldRef<"ServiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceItem", 'DateTime'>
    readonly name: FieldRef<"ServiceItem", 'String'>
    readonly description: FieldRef<"ServiceItem", 'String'>
    readonly defaultPrice: FieldRef<"ServiceItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ServiceItem findUnique
   */
  export type ServiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem findUniqueOrThrow
   */
  export type ServiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem findFirst
   */
  export type ServiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceItems.
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceItems.
     */
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * ServiceItem findFirstOrThrow
   */
  export type ServiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceItems.
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceItems.
     */
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * ServiceItem findMany
   */
  export type ServiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItems to fetch.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceItems.
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * ServiceItem create
   */
  export type ServiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceItem.
     */
    data: XOR<ServiceItemCreateInput, ServiceItemUncheckedCreateInput>
  }

  /**
   * ServiceItem createMany
   */
  export type ServiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceItems.
     */
    data: ServiceItemCreateManyInput | ServiceItemCreateManyInput[]
  }

  /**
   * ServiceItem createManyAndReturn
   */
  export type ServiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceItems.
     */
    data: ServiceItemCreateManyInput | ServiceItemCreateManyInput[]
  }

  /**
   * ServiceItem update
   */
  export type ServiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceItem.
     */
    data: XOR<ServiceItemUpdateInput, ServiceItemUncheckedUpdateInput>
    /**
     * Choose, which ServiceItem to update.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem updateMany
   */
  export type ServiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceItems.
     */
    data: XOR<ServiceItemUpdateManyMutationInput, ServiceItemUncheckedUpdateManyInput>
    /**
     * Filter which ServiceItems to update
     */
    where?: ServiceItemWhereInput
  }

  /**
   * ServiceItem upsert
   */
  export type ServiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceItem to update in case it exists.
     */
    where: ServiceItemWhereUniqueInput
    /**
     * In case the ServiceItem found by the `where` argument doesn't exist, create a new ServiceItem with this data.
     */
    create: XOR<ServiceItemCreateInput, ServiceItemUncheckedCreateInput>
    /**
     * In case the ServiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceItemUpdateInput, ServiceItemUncheckedUpdateInput>
  }

  /**
   * ServiceItem delete
   */
  export type ServiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter which ServiceItem to delete.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem deleteMany
   */
  export type ServiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceItems to delete
     */
    where?: ServiceItemWhereInput
  }

  /**
   * ServiceItem.lineItems
   */
  export type ServiceItem$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLineItem
     */
    select?: WorkOrderLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLineItemInclude<ExtArgs> | null
    where?: WorkOrderLineItemWhereInput
    orderBy?: WorkOrderLineItemOrderByWithRelationInput | WorkOrderLineItemOrderByWithRelationInput[]
    cursor?: WorkOrderLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderLineItemScalarFieldEnum | WorkOrderLineItemScalarFieldEnum[]
  }

  /**
   * ServiceItem without action
   */
  export type ServiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
  }


  /**
   * Model WorkOrderLog
   */

  export type AggregateWorkOrderLog = {
    _count: WorkOrderLogCountAggregateOutputType | null
    _avg: WorkOrderLogAvgAggregateOutputType | null
    _sum: WorkOrderLogSumAggregateOutputType | null
    _min: WorkOrderLogMinAggregateOutputType | null
    _max: WorkOrderLogMaxAggregateOutputType | null
  }

  export type WorkOrderLogAvgAggregateOutputType = {
    id: number | null
    workOrderId: number | null
  }

  export type WorkOrderLogSumAggregateOutputType = {
    id: number | null
    workOrderId: number | null
  }

  export type WorkOrderLogMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    workOrderId: number | null
    message: string | null
    author: string | null
    category: string | null
  }

  export type WorkOrderLogMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    workOrderId: number | null
    message: string | null
    author: string | null
    category: string | null
  }

  export type WorkOrderLogCountAggregateOutputType = {
    id: number
    timestamp: number
    workOrderId: number
    message: number
    author: number
    category: number
    _all: number
  }


  export type WorkOrderLogAvgAggregateInputType = {
    id?: true
    workOrderId?: true
  }

  export type WorkOrderLogSumAggregateInputType = {
    id?: true
    workOrderId?: true
  }

  export type WorkOrderLogMinAggregateInputType = {
    id?: true
    timestamp?: true
    workOrderId?: true
    message?: true
    author?: true
    category?: true
  }

  export type WorkOrderLogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    workOrderId?: true
    message?: true
    author?: true
    category?: true
  }

  export type WorkOrderLogCountAggregateInputType = {
    id?: true
    timestamp?: true
    workOrderId?: true
    message?: true
    author?: true
    category?: true
    _all?: true
  }

  export type WorkOrderLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrderLog to aggregate.
     */
    where?: WorkOrderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderLogs to fetch.
     */
    orderBy?: WorkOrderLogOrderByWithRelationInput | WorkOrderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkOrderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkOrderLogs
    **/
    _count?: true | WorkOrderLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkOrderLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkOrderLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkOrderLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkOrderLogMaxAggregateInputType
  }

  export type GetWorkOrderLogAggregateType<T extends WorkOrderLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkOrderLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkOrderLog[P]>
      : GetScalarType<T[P], AggregateWorkOrderLog[P]>
  }




  export type WorkOrderLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderLogWhereInput
    orderBy?: WorkOrderLogOrderByWithAggregationInput | WorkOrderLogOrderByWithAggregationInput[]
    by: WorkOrderLogScalarFieldEnum[] | WorkOrderLogScalarFieldEnum
    having?: WorkOrderLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkOrderLogCountAggregateInputType | true
    _avg?: WorkOrderLogAvgAggregateInputType
    _sum?: WorkOrderLogSumAggregateInputType
    _min?: WorkOrderLogMinAggregateInputType
    _max?: WorkOrderLogMaxAggregateInputType
  }

  export type WorkOrderLogGroupByOutputType = {
    id: number
    timestamp: Date
    workOrderId: number
    message: string
    author: string | null
    category: string | null
    _count: WorkOrderLogCountAggregateOutputType | null
    _avg: WorkOrderLogAvgAggregateOutputType | null
    _sum: WorkOrderLogSumAggregateOutputType | null
    _min: WorkOrderLogMinAggregateOutputType | null
    _max: WorkOrderLogMaxAggregateOutputType | null
  }

  type GetWorkOrderLogGroupByPayload<T extends WorkOrderLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkOrderLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkOrderLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkOrderLogGroupByOutputType[P]>
            : GetScalarType<T[P], WorkOrderLogGroupByOutputType[P]>
        }
      >
    >


  export type WorkOrderLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    workOrderId?: boolean
    message?: boolean
    author?: boolean
    category?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrderLog"]>

  export type WorkOrderLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    workOrderId?: boolean
    message?: boolean
    author?: boolean
    category?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrderLog"]>

  export type WorkOrderLogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    workOrderId?: boolean
    message?: boolean
    author?: boolean
    category?: boolean
  }

  export type WorkOrderLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }
  export type WorkOrderLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
  }

  export type $WorkOrderLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkOrderLog"
    objects: {
      workOrder: Prisma.$WorkOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      workOrderId: number
      message: string
      author: string | null
      category: string | null
    }, ExtArgs["result"]["workOrderLog"]>
    composites: {}
  }

  type WorkOrderLogGetPayload<S extends boolean | null | undefined | WorkOrderLogDefaultArgs> = $Result.GetResult<Prisma.$WorkOrderLogPayload, S>

  type WorkOrderLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkOrderLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkOrderLogCountAggregateInputType | true
    }

  export interface WorkOrderLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkOrderLog'], meta: { name: 'WorkOrderLog' } }
    /**
     * Find zero or one WorkOrderLog that matches the filter.
     * @param {WorkOrderLogFindUniqueArgs} args - Arguments to find a WorkOrderLog
     * @example
     * // Get one WorkOrderLog
     * const workOrderLog = await prisma.workOrderLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkOrderLogFindUniqueArgs>(args: SelectSubset<T, WorkOrderLogFindUniqueArgs<ExtArgs>>): Prisma__WorkOrderLogClient<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkOrderLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkOrderLogFindUniqueOrThrowArgs} args - Arguments to find a WorkOrderLog
     * @example
     * // Get one WorkOrderLog
     * const workOrderLog = await prisma.workOrderLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkOrderLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkOrderLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkOrderLogClient<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkOrderLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLogFindFirstArgs} args - Arguments to find a WorkOrderLog
     * @example
     * // Get one WorkOrderLog
     * const workOrderLog = await prisma.workOrderLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkOrderLogFindFirstArgs>(args?: SelectSubset<T, WorkOrderLogFindFirstArgs<ExtArgs>>): Prisma__WorkOrderLogClient<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkOrderLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLogFindFirstOrThrowArgs} args - Arguments to find a WorkOrderLog
     * @example
     * // Get one WorkOrderLog
     * const workOrderLog = await prisma.workOrderLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkOrderLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkOrderLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkOrderLogClient<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkOrderLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkOrderLogs
     * const workOrderLogs = await prisma.workOrderLog.findMany()
     * 
     * // Get first 10 WorkOrderLogs
     * const workOrderLogs = await prisma.workOrderLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workOrderLogWithIdOnly = await prisma.workOrderLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkOrderLogFindManyArgs>(args?: SelectSubset<T, WorkOrderLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkOrderLog.
     * @param {WorkOrderLogCreateArgs} args - Arguments to create a WorkOrderLog.
     * @example
     * // Create one WorkOrderLog
     * const WorkOrderLog = await prisma.workOrderLog.create({
     *   data: {
     *     // ... data to create a WorkOrderLog
     *   }
     * })
     * 
     */
    create<T extends WorkOrderLogCreateArgs>(args: SelectSubset<T, WorkOrderLogCreateArgs<ExtArgs>>): Prisma__WorkOrderLogClient<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkOrderLogs.
     * @param {WorkOrderLogCreateManyArgs} args - Arguments to create many WorkOrderLogs.
     * @example
     * // Create many WorkOrderLogs
     * const workOrderLog = await prisma.workOrderLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkOrderLogCreateManyArgs>(args?: SelectSubset<T, WorkOrderLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkOrderLogs and returns the data saved in the database.
     * @param {WorkOrderLogCreateManyAndReturnArgs} args - Arguments to create many WorkOrderLogs.
     * @example
     * // Create many WorkOrderLogs
     * const workOrderLog = await prisma.workOrderLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkOrderLogs and only return the `id`
     * const workOrderLogWithIdOnly = await prisma.workOrderLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkOrderLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkOrderLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkOrderLog.
     * @param {WorkOrderLogDeleteArgs} args - Arguments to delete one WorkOrderLog.
     * @example
     * // Delete one WorkOrderLog
     * const WorkOrderLog = await prisma.workOrderLog.delete({
     *   where: {
     *     // ... filter to delete one WorkOrderLog
     *   }
     * })
     * 
     */
    delete<T extends WorkOrderLogDeleteArgs>(args: SelectSubset<T, WorkOrderLogDeleteArgs<ExtArgs>>): Prisma__WorkOrderLogClient<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkOrderLog.
     * @param {WorkOrderLogUpdateArgs} args - Arguments to update one WorkOrderLog.
     * @example
     * // Update one WorkOrderLog
     * const workOrderLog = await prisma.workOrderLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkOrderLogUpdateArgs>(args: SelectSubset<T, WorkOrderLogUpdateArgs<ExtArgs>>): Prisma__WorkOrderLogClient<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkOrderLogs.
     * @param {WorkOrderLogDeleteManyArgs} args - Arguments to filter WorkOrderLogs to delete.
     * @example
     * // Delete a few WorkOrderLogs
     * const { count } = await prisma.workOrderLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkOrderLogDeleteManyArgs>(args?: SelectSubset<T, WorkOrderLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrderLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkOrderLogs
     * const workOrderLog = await prisma.workOrderLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkOrderLogUpdateManyArgs>(args: SelectSubset<T, WorkOrderLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkOrderLog.
     * @param {WorkOrderLogUpsertArgs} args - Arguments to update or create a WorkOrderLog.
     * @example
     * // Update or create a WorkOrderLog
     * const workOrderLog = await prisma.workOrderLog.upsert({
     *   create: {
     *     // ... data to create a WorkOrderLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkOrderLog we want to update
     *   }
     * })
     */
    upsert<T extends WorkOrderLogUpsertArgs>(args: SelectSubset<T, WorkOrderLogUpsertArgs<ExtArgs>>): Prisma__WorkOrderLogClient<$Result.GetResult<Prisma.$WorkOrderLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkOrderLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLogCountArgs} args - Arguments to filter WorkOrderLogs to count.
     * @example
     * // Count the number of WorkOrderLogs
     * const count = await prisma.workOrderLog.count({
     *   where: {
     *     // ... the filter for the WorkOrderLogs we want to count
     *   }
     * })
    **/
    count<T extends WorkOrderLogCountArgs>(
      args?: Subset<T, WorkOrderLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkOrderLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkOrderLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkOrderLogAggregateArgs>(args: Subset<T, WorkOrderLogAggregateArgs>): Prisma.PrismaPromise<GetWorkOrderLogAggregateType<T>>

    /**
     * Group by WorkOrderLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkOrderLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkOrderLogGroupByArgs['orderBy'] }
        : { orderBy?: WorkOrderLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkOrderLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkOrderLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkOrderLog model
   */
  readonly fields: WorkOrderLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkOrderLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkOrderLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workOrder<T extends WorkOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrderDefaultArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkOrderLog model
   */ 
  interface WorkOrderLogFieldRefs {
    readonly id: FieldRef<"WorkOrderLog", 'Int'>
    readonly timestamp: FieldRef<"WorkOrderLog", 'DateTime'>
    readonly workOrderId: FieldRef<"WorkOrderLog", 'Int'>
    readonly message: FieldRef<"WorkOrderLog", 'String'>
    readonly author: FieldRef<"WorkOrderLog", 'String'>
    readonly category: FieldRef<"WorkOrderLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkOrderLog findUnique
   */
  export type WorkOrderLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLog to fetch.
     */
    where: WorkOrderLogWhereUniqueInput
  }

  /**
   * WorkOrderLog findUniqueOrThrow
   */
  export type WorkOrderLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLog to fetch.
     */
    where: WorkOrderLogWhereUniqueInput
  }

  /**
   * WorkOrderLog findFirst
   */
  export type WorkOrderLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLog to fetch.
     */
    where?: WorkOrderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderLogs to fetch.
     */
    orderBy?: WorkOrderLogOrderByWithRelationInput | WorkOrderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrderLogs.
     */
    cursor?: WorkOrderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrderLogs.
     */
    distinct?: WorkOrderLogScalarFieldEnum | WorkOrderLogScalarFieldEnum[]
  }

  /**
   * WorkOrderLog findFirstOrThrow
   */
  export type WorkOrderLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLog to fetch.
     */
    where?: WorkOrderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderLogs to fetch.
     */
    orderBy?: WorkOrderLogOrderByWithRelationInput | WorkOrderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrderLogs.
     */
    cursor?: WorkOrderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrderLogs.
     */
    distinct?: WorkOrderLogScalarFieldEnum | WorkOrderLogScalarFieldEnum[]
  }

  /**
   * WorkOrderLog findMany
   */
  export type WorkOrderLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderLogs to fetch.
     */
    where?: WorkOrderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderLogs to fetch.
     */
    orderBy?: WorkOrderLogOrderByWithRelationInput | WorkOrderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkOrderLogs.
     */
    cursor?: WorkOrderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderLogs.
     */
    skip?: number
    distinct?: WorkOrderLogScalarFieldEnum | WorkOrderLogScalarFieldEnum[]
  }

  /**
   * WorkOrderLog create
   */
  export type WorkOrderLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkOrderLog.
     */
    data: XOR<WorkOrderLogCreateInput, WorkOrderLogUncheckedCreateInput>
  }

  /**
   * WorkOrderLog createMany
   */
  export type WorkOrderLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkOrderLogs.
     */
    data: WorkOrderLogCreateManyInput | WorkOrderLogCreateManyInput[]
  }

  /**
   * WorkOrderLog createManyAndReturn
   */
  export type WorkOrderLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkOrderLogs.
     */
    data: WorkOrderLogCreateManyInput | WorkOrderLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkOrderLog update
   */
  export type WorkOrderLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkOrderLog.
     */
    data: XOR<WorkOrderLogUpdateInput, WorkOrderLogUncheckedUpdateInput>
    /**
     * Choose, which WorkOrderLog to update.
     */
    where: WorkOrderLogWhereUniqueInput
  }

  /**
   * WorkOrderLog updateMany
   */
  export type WorkOrderLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkOrderLogs.
     */
    data: XOR<WorkOrderLogUpdateManyMutationInput, WorkOrderLogUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrderLogs to update
     */
    where?: WorkOrderLogWhereInput
  }

  /**
   * WorkOrderLog upsert
   */
  export type WorkOrderLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkOrderLog to update in case it exists.
     */
    where: WorkOrderLogWhereUniqueInput
    /**
     * In case the WorkOrderLog found by the `where` argument doesn't exist, create a new WorkOrderLog with this data.
     */
    create: XOR<WorkOrderLogCreateInput, WorkOrderLogUncheckedCreateInput>
    /**
     * In case the WorkOrderLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkOrderLogUpdateInput, WorkOrderLogUncheckedUpdateInput>
  }

  /**
   * WorkOrderLog delete
   */
  export type WorkOrderLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
    /**
     * Filter which WorkOrderLog to delete.
     */
    where: WorkOrderLogWhereUniqueInput
  }

  /**
   * WorkOrderLog deleteMany
   */
  export type WorkOrderLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrderLogs to delete
     */
    where?: WorkOrderLogWhereInput
  }

  /**
   * WorkOrderLog without action
   */
  export type WorkOrderLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderLog
     */
    select?: WorkOrderLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderLogInclude<ExtArgs> | null
  }


  /**
   * Model Worker
   */

  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerAvgAggregateOutputType = {
    id: number | null
    commuteExpense: Decimal | null
    shiftExpense: Decimal | null
    mealExpense: Decimal | null
    otherExpense: Decimal | null
    totalJobs: number | null
    totalServices: number | null
  }

  export type WorkerSumAggregateOutputType = {
    id: number | null
    commuteExpense: Decimal | null
    shiftExpense: Decimal | null
    mealExpense: Decimal | null
    otherExpense: Decimal | null
    totalJobs: number | null
    totalServices: number | null
  }

  export type WorkerMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    email: string | null
    phone: string | null
    commuteExpense: Decimal | null
    shiftExpense: Decimal | null
    mealExpense: Decimal | null
    otherExpense: Decimal | null
    totalJobs: number | null
    totalServices: number | null
  }

  export type WorkerMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    email: string | null
    phone: string | null
    commuteExpense: Decimal | null
    shiftExpense: Decimal | null
    mealExpense: Decimal | null
    otherExpense: Decimal | null
    totalJobs: number | null
    totalServices: number | null
  }

  export type WorkerCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    email: number
    phone: number
    commuteExpense: number
    shiftExpense: number
    mealExpense: number
    otherExpense: number
    totalJobs: number
    totalServices: number
    _all: number
  }


  export type WorkerAvgAggregateInputType = {
    id?: true
    commuteExpense?: true
    shiftExpense?: true
    mealExpense?: true
    otherExpense?: true
    totalJobs?: true
    totalServices?: true
  }

  export type WorkerSumAggregateInputType = {
    id?: true
    commuteExpense?: true
    shiftExpense?: true
    mealExpense?: true
    otherExpense?: true
    totalJobs?: true
    totalServices?: true
  }

  export type WorkerMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    phone?: true
    commuteExpense?: true
    shiftExpense?: true
    mealExpense?: true
    otherExpense?: true
    totalJobs?: true
    totalServices?: true
  }

  export type WorkerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    phone?: true
    commuteExpense?: true
    shiftExpense?: true
    mealExpense?: true
    otherExpense?: true
    totalJobs?: true
    totalServices?: true
  }

  export type WorkerCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    phone?: true
    commuteExpense?: true
    shiftExpense?: true
    mealExpense?: true
    otherExpense?: true
    totalJobs?: true
    totalServices?: true
    _all?: true
  }

  export type WorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worker to aggregate.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }




  export type WorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithAggregationInput | WorkerOrderByWithAggregationInput[]
    by: WorkerScalarFieldEnum[] | WorkerScalarFieldEnum
    having?: WorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _avg?: WorkerAvgAggregateInputType
    _sum?: WorkerSumAggregateInputType
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }

  export type WorkerGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    email: string | null
    phone: string | null
    commuteExpense: Decimal
    shiftExpense: Decimal
    mealExpense: Decimal
    otherExpense: Decimal
    totalJobs: number
    totalServices: number
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      >
    >


  export type WorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    commuteExpense?: boolean
    shiftExpense?: boolean
    mealExpense?: boolean
    otherExpense?: boolean
    totalJobs?: boolean
    totalServices?: boolean
    assignments?: boolean | Worker$assignmentsArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    commuteExpense?: boolean
    shiftExpense?: boolean
    mealExpense?: boolean
    otherExpense?: boolean
    totalJobs?: boolean
    totalServices?: boolean
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    commuteExpense?: boolean
    shiftExpense?: boolean
    mealExpense?: boolean
    otherExpense?: boolean
    totalJobs?: boolean
    totalServices?: boolean
  }

  export type WorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Worker$assignmentsArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Worker"
    objects: {
      assignments: Prisma.$WorkOrderAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string
      email: string | null
      phone: string | null
      commuteExpense: Prisma.Decimal
      shiftExpense: Prisma.Decimal
      mealExpense: Prisma.Decimal
      otherExpense: Prisma.Decimal
      totalJobs: number
      totalServices: number
    }, ExtArgs["result"]["worker"]>
    composites: {}
  }

  type WorkerGetPayload<S extends boolean | null | undefined | WorkerDefaultArgs> = $Result.GetResult<Prisma.$WorkerPayload, S>

  type WorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkerCountAggregateInputType | true
    }

  export interface WorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Worker'], meta: { name: 'Worker' } }
    /**
     * Find zero or one Worker that matches the filter.
     * @param {WorkerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerFindUniqueArgs>(args: SelectSubset<T, WorkerFindUniqueArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Worker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkerFindUniqueOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerFindFirstArgs>(args?: SelectSubset<T, WorkerFindFirstArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Worker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerFindManyArgs>(args?: SelectSubset<T, WorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Worker.
     * @param {WorkerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
     */
    create<T extends WorkerCreateArgs>(args: SelectSubset<T, WorkerCreateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workers.
     * @param {WorkerCreateManyArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerCreateManyArgs>(args?: SelectSubset<T, WorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workers and returns the data saved in the database.
     * @param {WorkerCreateManyAndReturnArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workers and only return the `id`
     * const workerWithIdOnly = await prisma.worker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Worker.
     * @param {WorkerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
     */
    delete<T extends WorkerDeleteArgs>(args: SelectSubset<T, WorkerDeleteArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Worker.
     * @param {WorkerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerUpdateArgs>(args: SelectSubset<T, WorkerUpdateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workers.
     * @param {WorkerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerDeleteManyArgs>(args?: SelectSubset<T, WorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerUpdateManyArgs>(args: SelectSubset<T, WorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Worker.
     * @param {WorkerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
     */
    upsert<T extends WorkerUpsertArgs>(args: SelectSubset<T, WorkerUpsertArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends WorkerCountArgs>(
      args?: Subset<T, WorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): Prisma.PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Worker model
   */
  readonly fields: WorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Worker$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Worker$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Worker model
   */ 
  interface WorkerFieldRefs {
    readonly id: FieldRef<"Worker", 'Int'>
    readonly createdAt: FieldRef<"Worker", 'DateTime'>
    readonly updatedAt: FieldRef<"Worker", 'DateTime'>
    readonly name: FieldRef<"Worker", 'String'>
    readonly email: FieldRef<"Worker", 'String'>
    readonly phone: FieldRef<"Worker", 'String'>
    readonly commuteExpense: FieldRef<"Worker", 'Decimal'>
    readonly shiftExpense: FieldRef<"Worker", 'Decimal'>
    readonly mealExpense: FieldRef<"Worker", 'Decimal'>
    readonly otherExpense: FieldRef<"Worker", 'Decimal'>
    readonly totalJobs: FieldRef<"Worker", 'Int'>
    readonly totalServices: FieldRef<"Worker", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Worker findUnique
   */
  export type WorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findUniqueOrThrow
   */
  export type WorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findFirst
   */
  export type WorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findFirstOrThrow
   */
  export type WorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findMany
   */
  export type WorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Workers to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker create
   */
  export type WorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Worker.
     */
    data: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
  }

  /**
   * Worker createMany
   */
  export type WorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
  }

  /**
   * Worker createManyAndReturn
   */
  export type WorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
  }

  /**
   * Worker update
   */
  export type WorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Worker.
     */
    data: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
    /**
     * Choose, which Worker to update.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker updateMany
   */
  export type WorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker upsert
   */
  export type WorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Worker to update in case it exists.
     */
    where: WorkerWhereUniqueInput
    /**
     * In case the Worker found by the `where` argument doesn't exist, create a new Worker with this data.
     */
    create: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
    /**
     * In case the Worker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
  }

  /**
   * Worker delete
   */
  export type WorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter which Worker to delete.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker deleteMany
   */
  export type WorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workers to delete
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker.assignments
   */
  export type Worker$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    where?: WorkOrderAssignmentWhereInput
    orderBy?: WorkOrderAssignmentOrderByWithRelationInput | WorkOrderAssignmentOrderByWithRelationInput[]
    cursor?: WorkOrderAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderAssignmentScalarFieldEnum | WorkOrderAssignmentScalarFieldEnum[]
  }

  /**
   * Worker without action
   */
  export type WorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
  }


  /**
   * Model WorkOrderAssignment
   */

  export type AggregateWorkOrderAssignment = {
    _count: WorkOrderAssignmentCountAggregateOutputType | null
    _avg: WorkOrderAssignmentAvgAggregateOutputType | null
    _sum: WorkOrderAssignmentSumAggregateOutputType | null
    _min: WorkOrderAssignmentMinAggregateOutputType | null
    _max: WorkOrderAssignmentMaxAggregateOutputType | null
  }

  export type WorkOrderAssignmentAvgAggregateOutputType = {
    id: number | null
    workOrderId: number | null
    workerId: number | null
    servicesCount: number | null
  }

  export type WorkOrderAssignmentSumAggregateOutputType = {
    id: number | null
    workOrderId: number | null
    workerId: number | null
    servicesCount: number | null
  }

  export type WorkOrderAssignmentMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    workOrderId: number | null
    workerId: number | null
    role: string | null
    notes: string | null
    servicesCount: number | null
  }

  export type WorkOrderAssignmentMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    workOrderId: number | null
    workerId: number | null
    role: string | null
    notes: string | null
    servicesCount: number | null
  }

  export type WorkOrderAssignmentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    workOrderId: number
    workerId: number
    role: number
    notes: number
    servicesCount: number
    _all: number
  }


  export type WorkOrderAssignmentAvgAggregateInputType = {
    id?: true
    workOrderId?: true
    workerId?: true
    servicesCount?: true
  }

  export type WorkOrderAssignmentSumAggregateInputType = {
    id?: true
    workOrderId?: true
    workerId?: true
    servicesCount?: true
  }

  export type WorkOrderAssignmentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    workOrderId?: true
    workerId?: true
    role?: true
    notes?: true
    servicesCount?: true
  }

  export type WorkOrderAssignmentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    workOrderId?: true
    workerId?: true
    role?: true
    notes?: true
    servicesCount?: true
  }

  export type WorkOrderAssignmentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    workOrderId?: true
    workerId?: true
    role?: true
    notes?: true
    servicesCount?: true
    _all?: true
  }

  export type WorkOrderAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrderAssignment to aggregate.
     */
    where?: WorkOrderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderAssignments to fetch.
     */
    orderBy?: WorkOrderAssignmentOrderByWithRelationInput | WorkOrderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkOrderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkOrderAssignments
    **/
    _count?: true | WorkOrderAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkOrderAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkOrderAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkOrderAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkOrderAssignmentMaxAggregateInputType
  }

  export type GetWorkOrderAssignmentAggregateType<T extends WorkOrderAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkOrderAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkOrderAssignment[P]>
      : GetScalarType<T[P], AggregateWorkOrderAssignment[P]>
  }




  export type WorkOrderAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderAssignmentWhereInput
    orderBy?: WorkOrderAssignmentOrderByWithAggregationInput | WorkOrderAssignmentOrderByWithAggregationInput[]
    by: WorkOrderAssignmentScalarFieldEnum[] | WorkOrderAssignmentScalarFieldEnum
    having?: WorkOrderAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkOrderAssignmentCountAggregateInputType | true
    _avg?: WorkOrderAssignmentAvgAggregateInputType
    _sum?: WorkOrderAssignmentSumAggregateInputType
    _min?: WorkOrderAssignmentMinAggregateInputType
    _max?: WorkOrderAssignmentMaxAggregateInputType
  }

  export type WorkOrderAssignmentGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    workOrderId: number
    workerId: number
    role: string | null
    notes: string | null
    servicesCount: number
    _count: WorkOrderAssignmentCountAggregateOutputType | null
    _avg: WorkOrderAssignmentAvgAggregateOutputType | null
    _sum: WorkOrderAssignmentSumAggregateOutputType | null
    _min: WorkOrderAssignmentMinAggregateOutputType | null
    _max: WorkOrderAssignmentMaxAggregateOutputType | null
  }

  type GetWorkOrderAssignmentGroupByPayload<T extends WorkOrderAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkOrderAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkOrderAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkOrderAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], WorkOrderAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type WorkOrderAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workOrderId?: boolean
    workerId?: boolean
    role?: boolean
    notes?: boolean
    servicesCount?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    worker?: boolean | WorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrderAssignment"]>

  export type WorkOrderAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workOrderId?: boolean
    workerId?: boolean
    role?: boolean
    notes?: boolean
    servicesCount?: boolean
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    worker?: boolean | WorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrderAssignment"]>

  export type WorkOrderAssignmentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workOrderId?: boolean
    workerId?: boolean
    role?: boolean
    notes?: boolean
    servicesCount?: boolean
  }

  export type WorkOrderAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    worker?: boolean | WorkerDefaultArgs<ExtArgs>
  }
  export type WorkOrderAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workOrder?: boolean | WorkOrderDefaultArgs<ExtArgs>
    worker?: boolean | WorkerDefaultArgs<ExtArgs>
  }

  export type $WorkOrderAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkOrderAssignment"
    objects: {
      workOrder: Prisma.$WorkOrderPayload<ExtArgs>
      worker: Prisma.$WorkerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      workOrderId: number
      workerId: number
      role: string | null
      notes: string | null
      servicesCount: number
    }, ExtArgs["result"]["workOrderAssignment"]>
    composites: {}
  }

  type WorkOrderAssignmentGetPayload<S extends boolean | null | undefined | WorkOrderAssignmentDefaultArgs> = $Result.GetResult<Prisma.$WorkOrderAssignmentPayload, S>

  type WorkOrderAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkOrderAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkOrderAssignmentCountAggregateInputType | true
    }

  export interface WorkOrderAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkOrderAssignment'], meta: { name: 'WorkOrderAssignment' } }
    /**
     * Find zero or one WorkOrderAssignment that matches the filter.
     * @param {WorkOrderAssignmentFindUniqueArgs} args - Arguments to find a WorkOrderAssignment
     * @example
     * // Get one WorkOrderAssignment
     * const workOrderAssignment = await prisma.workOrderAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkOrderAssignmentFindUniqueArgs>(args: SelectSubset<T, WorkOrderAssignmentFindUniqueArgs<ExtArgs>>): Prisma__WorkOrderAssignmentClient<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkOrderAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkOrderAssignmentFindUniqueOrThrowArgs} args - Arguments to find a WorkOrderAssignment
     * @example
     * // Get one WorkOrderAssignment
     * const workOrderAssignment = await prisma.workOrderAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkOrderAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkOrderAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkOrderAssignmentClient<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkOrderAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAssignmentFindFirstArgs} args - Arguments to find a WorkOrderAssignment
     * @example
     * // Get one WorkOrderAssignment
     * const workOrderAssignment = await prisma.workOrderAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkOrderAssignmentFindFirstArgs>(args?: SelectSubset<T, WorkOrderAssignmentFindFirstArgs<ExtArgs>>): Prisma__WorkOrderAssignmentClient<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkOrderAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAssignmentFindFirstOrThrowArgs} args - Arguments to find a WorkOrderAssignment
     * @example
     * // Get one WorkOrderAssignment
     * const workOrderAssignment = await prisma.workOrderAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkOrderAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkOrderAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkOrderAssignmentClient<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkOrderAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkOrderAssignments
     * const workOrderAssignments = await prisma.workOrderAssignment.findMany()
     * 
     * // Get first 10 WorkOrderAssignments
     * const workOrderAssignments = await prisma.workOrderAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workOrderAssignmentWithIdOnly = await prisma.workOrderAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkOrderAssignmentFindManyArgs>(args?: SelectSubset<T, WorkOrderAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkOrderAssignment.
     * @param {WorkOrderAssignmentCreateArgs} args - Arguments to create a WorkOrderAssignment.
     * @example
     * // Create one WorkOrderAssignment
     * const WorkOrderAssignment = await prisma.workOrderAssignment.create({
     *   data: {
     *     // ... data to create a WorkOrderAssignment
     *   }
     * })
     * 
     */
    create<T extends WorkOrderAssignmentCreateArgs>(args: SelectSubset<T, WorkOrderAssignmentCreateArgs<ExtArgs>>): Prisma__WorkOrderAssignmentClient<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkOrderAssignments.
     * @param {WorkOrderAssignmentCreateManyArgs} args - Arguments to create many WorkOrderAssignments.
     * @example
     * // Create many WorkOrderAssignments
     * const workOrderAssignment = await prisma.workOrderAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkOrderAssignmentCreateManyArgs>(args?: SelectSubset<T, WorkOrderAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkOrderAssignments and returns the data saved in the database.
     * @param {WorkOrderAssignmentCreateManyAndReturnArgs} args - Arguments to create many WorkOrderAssignments.
     * @example
     * // Create many WorkOrderAssignments
     * const workOrderAssignment = await prisma.workOrderAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkOrderAssignments and only return the `id`
     * const workOrderAssignmentWithIdOnly = await prisma.workOrderAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkOrderAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkOrderAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkOrderAssignment.
     * @param {WorkOrderAssignmentDeleteArgs} args - Arguments to delete one WorkOrderAssignment.
     * @example
     * // Delete one WorkOrderAssignment
     * const WorkOrderAssignment = await prisma.workOrderAssignment.delete({
     *   where: {
     *     // ... filter to delete one WorkOrderAssignment
     *   }
     * })
     * 
     */
    delete<T extends WorkOrderAssignmentDeleteArgs>(args: SelectSubset<T, WorkOrderAssignmentDeleteArgs<ExtArgs>>): Prisma__WorkOrderAssignmentClient<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkOrderAssignment.
     * @param {WorkOrderAssignmentUpdateArgs} args - Arguments to update one WorkOrderAssignment.
     * @example
     * // Update one WorkOrderAssignment
     * const workOrderAssignment = await prisma.workOrderAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkOrderAssignmentUpdateArgs>(args: SelectSubset<T, WorkOrderAssignmentUpdateArgs<ExtArgs>>): Prisma__WorkOrderAssignmentClient<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkOrderAssignments.
     * @param {WorkOrderAssignmentDeleteManyArgs} args - Arguments to filter WorkOrderAssignments to delete.
     * @example
     * // Delete a few WorkOrderAssignments
     * const { count } = await prisma.workOrderAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkOrderAssignmentDeleteManyArgs>(args?: SelectSubset<T, WorkOrderAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrderAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkOrderAssignments
     * const workOrderAssignment = await prisma.workOrderAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkOrderAssignmentUpdateManyArgs>(args: SelectSubset<T, WorkOrderAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkOrderAssignment.
     * @param {WorkOrderAssignmentUpsertArgs} args - Arguments to update or create a WorkOrderAssignment.
     * @example
     * // Update or create a WorkOrderAssignment
     * const workOrderAssignment = await prisma.workOrderAssignment.upsert({
     *   create: {
     *     // ... data to create a WorkOrderAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkOrderAssignment we want to update
     *   }
     * })
     */
    upsert<T extends WorkOrderAssignmentUpsertArgs>(args: SelectSubset<T, WorkOrderAssignmentUpsertArgs<ExtArgs>>): Prisma__WorkOrderAssignmentClient<$Result.GetResult<Prisma.$WorkOrderAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkOrderAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAssignmentCountArgs} args - Arguments to filter WorkOrderAssignments to count.
     * @example
     * // Count the number of WorkOrderAssignments
     * const count = await prisma.workOrderAssignment.count({
     *   where: {
     *     // ... the filter for the WorkOrderAssignments we want to count
     *   }
     * })
    **/
    count<T extends WorkOrderAssignmentCountArgs>(
      args?: Subset<T, WorkOrderAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkOrderAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkOrderAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkOrderAssignmentAggregateArgs>(args: Subset<T, WorkOrderAssignmentAggregateArgs>): Prisma.PrismaPromise<GetWorkOrderAssignmentAggregateType<T>>

    /**
     * Group by WorkOrderAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkOrderAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkOrderAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: WorkOrderAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkOrderAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkOrderAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkOrderAssignment model
   */
  readonly fields: WorkOrderAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkOrderAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkOrderAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workOrder<T extends WorkOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrderDefaultArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    worker<T extends WorkerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkerDefaultArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkOrderAssignment model
   */ 
  interface WorkOrderAssignmentFieldRefs {
    readonly id: FieldRef<"WorkOrderAssignment", 'Int'>
    readonly createdAt: FieldRef<"WorkOrderAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkOrderAssignment", 'DateTime'>
    readonly workOrderId: FieldRef<"WorkOrderAssignment", 'Int'>
    readonly workerId: FieldRef<"WorkOrderAssignment", 'Int'>
    readonly role: FieldRef<"WorkOrderAssignment", 'String'>
    readonly notes: FieldRef<"WorkOrderAssignment", 'String'>
    readonly servicesCount: FieldRef<"WorkOrderAssignment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WorkOrderAssignment findUnique
   */
  export type WorkOrderAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderAssignment to fetch.
     */
    where: WorkOrderAssignmentWhereUniqueInput
  }

  /**
   * WorkOrderAssignment findUniqueOrThrow
   */
  export type WorkOrderAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderAssignment to fetch.
     */
    where: WorkOrderAssignmentWhereUniqueInput
  }

  /**
   * WorkOrderAssignment findFirst
   */
  export type WorkOrderAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderAssignment to fetch.
     */
    where?: WorkOrderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderAssignments to fetch.
     */
    orderBy?: WorkOrderAssignmentOrderByWithRelationInput | WorkOrderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrderAssignments.
     */
    cursor?: WorkOrderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrderAssignments.
     */
    distinct?: WorkOrderAssignmentScalarFieldEnum | WorkOrderAssignmentScalarFieldEnum[]
  }

  /**
   * WorkOrderAssignment findFirstOrThrow
   */
  export type WorkOrderAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderAssignment to fetch.
     */
    where?: WorkOrderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderAssignments to fetch.
     */
    orderBy?: WorkOrderAssignmentOrderByWithRelationInput | WorkOrderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrderAssignments.
     */
    cursor?: WorkOrderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrderAssignments.
     */
    distinct?: WorkOrderAssignmentScalarFieldEnum | WorkOrderAssignmentScalarFieldEnum[]
  }

  /**
   * WorkOrderAssignment findMany
   */
  export type WorkOrderAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrderAssignments to fetch.
     */
    where?: WorkOrderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrderAssignments to fetch.
     */
    orderBy?: WorkOrderAssignmentOrderByWithRelationInput | WorkOrderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkOrderAssignments.
     */
    cursor?: WorkOrderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrderAssignments.
     */
    skip?: number
    distinct?: WorkOrderAssignmentScalarFieldEnum | WorkOrderAssignmentScalarFieldEnum[]
  }

  /**
   * WorkOrderAssignment create
   */
  export type WorkOrderAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkOrderAssignment.
     */
    data: XOR<WorkOrderAssignmentCreateInput, WorkOrderAssignmentUncheckedCreateInput>
  }

  /**
   * WorkOrderAssignment createMany
   */
  export type WorkOrderAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkOrderAssignments.
     */
    data: WorkOrderAssignmentCreateManyInput | WorkOrderAssignmentCreateManyInput[]
  }

  /**
   * WorkOrderAssignment createManyAndReturn
   */
  export type WorkOrderAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkOrderAssignments.
     */
    data: WorkOrderAssignmentCreateManyInput | WorkOrderAssignmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkOrderAssignment update
   */
  export type WorkOrderAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkOrderAssignment.
     */
    data: XOR<WorkOrderAssignmentUpdateInput, WorkOrderAssignmentUncheckedUpdateInput>
    /**
     * Choose, which WorkOrderAssignment to update.
     */
    where: WorkOrderAssignmentWhereUniqueInput
  }

  /**
   * WorkOrderAssignment updateMany
   */
  export type WorkOrderAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkOrderAssignments.
     */
    data: XOR<WorkOrderAssignmentUpdateManyMutationInput, WorkOrderAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrderAssignments to update
     */
    where?: WorkOrderAssignmentWhereInput
  }

  /**
   * WorkOrderAssignment upsert
   */
  export type WorkOrderAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkOrderAssignment to update in case it exists.
     */
    where: WorkOrderAssignmentWhereUniqueInput
    /**
     * In case the WorkOrderAssignment found by the `where` argument doesn't exist, create a new WorkOrderAssignment with this data.
     */
    create: XOR<WorkOrderAssignmentCreateInput, WorkOrderAssignmentUncheckedCreateInput>
    /**
     * In case the WorkOrderAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkOrderAssignmentUpdateInput, WorkOrderAssignmentUncheckedUpdateInput>
  }

  /**
   * WorkOrderAssignment delete
   */
  export type WorkOrderAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter which WorkOrderAssignment to delete.
     */
    where: WorkOrderAssignmentWhereUniqueInput
  }

  /**
   * WorkOrderAssignment deleteMany
   */
  export type WorkOrderAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrderAssignments to delete
     */
    where?: WorkOrderAssignmentWhereInput
  }

  /**
   * WorkOrderAssignment without action
   */
  export type WorkOrderAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrderAssignment
     */
    select?: WorkOrderAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderAssignmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    company: 'company',
    notes: 'notes',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    customerId: 'customerId',
    vin: 'vin',
    make: 'make',
    model: 'model',
    year: 'year',
    licensePlate: 'licensePlate',
    mileage: 'mileage',
    color: 'color',
    engine: 'engine',
    notes: 'notes'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const WorkOrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    code: 'code',
    customerId: 'customerId',
    vehicleId: 'vehicleId',
    status: 'status',
    description: 'description',
    scheduledDate: 'scheduledDate',
    completedDate: 'completedDate',
    laborCost: 'laborCost',
    partsCost: 'partsCost',
    taxes: 'taxes',
    discount: 'discount',
    totalCost: 'totalCost',
    notes: 'notes',
    parkingCharge: 'parkingCharge',
    arrivalDate: 'arrivalDate',
    quotedAt: 'quotedAt',
    isHistorical: 'isHistorical'
  };

  export type WorkOrderScalarFieldEnum = (typeof WorkOrderScalarFieldEnum)[keyof typeof WorkOrderScalarFieldEnum]


  export const WorkOrderLineItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    workOrderId: 'workOrderId',
    inventoryItemId: 'inventoryItemId',
    serviceItemId: 'serviceItemId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    lineTotal: 'lineTotal'
  };

  export type WorkOrderLineItemScalarFieldEnum = (typeof WorkOrderLineItemScalarFieldEnum)[keyof typeof WorkOrderLineItemScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    sku: 'sku',
    description: 'description',
    quantityOnHand: 'quantityOnHand',
    reorderPoint: 'reorderPoint',
    unitCost: 'unitCost',
    unitPrice: 'unitPrice'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const ServiceItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    defaultPrice: 'defaultPrice'
  };

  export type ServiceItemScalarFieldEnum = (typeof ServiceItemScalarFieldEnum)[keyof typeof ServiceItemScalarFieldEnum]


  export const WorkOrderLogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    workOrderId: 'workOrderId',
    message: 'message',
    author: 'author',
    category: 'category'
  };

  export type WorkOrderLogScalarFieldEnum = (typeof WorkOrderLogScalarFieldEnum)[keyof typeof WorkOrderLogScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    email: 'email',
    phone: 'phone',
    commuteExpense: 'commuteExpense',
    shiftExpense: 'shiftExpense',
    mealExpense: 'mealExpense',
    otherExpense: 'otherExpense',
    totalJobs: 'totalJobs',
    totalServices: 'totalServices'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const WorkOrderAssignmentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workOrderId: 'workOrderId',
    workerId: 'workerId',
    role: 'role',
    notes: 'notes',
    servicesCount: 'servicesCount'
  };

  export type WorkOrderAssignmentScalarFieldEnum = (typeof WorkOrderAssignmentScalarFieldEnum)[keyof typeof WorkOrderAssignmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringFilter<"Customer"> | string
    company?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    addressLine1?: StringNullableFilter<"Customer"> | string | null
    addressLine2?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    state?: StringNullableFilter<"Customer"> | string | null
    postalCode?: StringNullableFilter<"Customer"> | string | null
    vehicles?: VehicleListRelationFilter
    workOrders?: WorkOrderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    company?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    vehicles?: VehicleOrderByRelationAggregateInput
    workOrders?: WorkOrderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    company?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    addressLine1?: StringNullableFilter<"Customer"> | string | null
    addressLine2?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    state?: StringNullableFilter<"Customer"> | string | null
    postalCode?: StringNullableFilter<"Customer"> | string | null
    vehicles?: VehicleListRelationFilter
    workOrders?: WorkOrderListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    company?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    firstName?: StringWithAggregatesFilter<"Customer"> | string
    lastName?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringWithAggregatesFilter<"Customer"> | string
    company?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    city?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    state?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: IntFilter<"Vehicle"> | number
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    customerId?: IntFilter<"Vehicle"> | number
    vin?: StringFilter<"Vehicle"> | string
    make?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    licensePlate?: StringNullableFilter<"Vehicle"> | string | null
    mileage?: IntNullableFilter<"Vehicle"> | number | null
    color?: StringNullableFilter<"Vehicle"> | string | null
    engine?: StringNullableFilter<"Vehicle"> | string | null
    notes?: StringNullableFilter<"Vehicle"> | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    workOrders?: WorkOrderListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    vin?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrderInput | SortOrder
    mileage?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    engine?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    workOrders?: WorkOrderOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    vin?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    customerId?: IntFilter<"Vehicle"> | number
    make?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    licensePlate?: StringNullableFilter<"Vehicle"> | string | null
    mileage?: IntNullableFilter<"Vehicle"> | number | null
    color?: StringNullableFilter<"Vehicle"> | string | null
    engine?: StringNullableFilter<"Vehicle"> | string | null
    notes?: StringNullableFilter<"Vehicle"> | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    workOrders?: WorkOrderListRelationFilter
  }, "id" | "vin">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    vin?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrderInput | SortOrder
    mileage?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    engine?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vehicle"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    customerId?: IntWithAggregatesFilter<"Vehicle"> | number
    vin?: StringWithAggregatesFilter<"Vehicle"> | string
    make?: StringWithAggregatesFilter<"Vehicle"> | string
    model?: StringWithAggregatesFilter<"Vehicle"> | string
    year?: IntWithAggregatesFilter<"Vehicle"> | number
    licensePlate?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    mileage?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    color?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    engine?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
  }

  export type WorkOrderWhereInput = {
    AND?: WorkOrderWhereInput | WorkOrderWhereInput[]
    OR?: WorkOrderWhereInput[]
    NOT?: WorkOrderWhereInput | WorkOrderWhereInput[]
    id?: IntFilter<"WorkOrder"> | number
    createdAt?: DateTimeFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrder"> | Date | string
    code?: StringFilter<"WorkOrder"> | string
    customerId?: IntNullableFilter<"WorkOrder"> | number | null
    vehicleId?: IntFilter<"WorkOrder"> | number
    status?: StringFilter<"WorkOrder"> | string
    description?: StringFilter<"WorkOrder"> | string
    scheduledDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    laborCost?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"WorkOrder"> | string | null
    parkingCharge?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    arrivalDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    quotedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    isHistorical?: BoolFilter<"WorkOrder"> | boolean
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    lineItems?: WorkOrderLineItemListRelationFilter
    logs?: WorkOrderLogListRelationFilter
    assignments?: WorkOrderAssignmentListRelationFilter
  }

  export type WorkOrderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    customerId?: SortOrderInput | SortOrder
    vehicleId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    taxes?: SortOrder
    discount?: SortOrder
    totalCost?: SortOrder
    notes?: SortOrderInput | SortOrder
    parkingCharge?: SortOrder
    arrivalDate?: SortOrderInput | SortOrder
    quotedAt?: SortOrderInput | SortOrder
    isHistorical?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    lineItems?: WorkOrderLineItemOrderByRelationAggregateInput
    logs?: WorkOrderLogOrderByRelationAggregateInput
    assignments?: WorkOrderAssignmentOrderByRelationAggregateInput
  }

  export type WorkOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: WorkOrderWhereInput | WorkOrderWhereInput[]
    OR?: WorkOrderWhereInput[]
    NOT?: WorkOrderWhereInput | WorkOrderWhereInput[]
    createdAt?: DateTimeFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrder"> | Date | string
    customerId?: IntNullableFilter<"WorkOrder"> | number | null
    vehicleId?: IntFilter<"WorkOrder"> | number
    status?: StringFilter<"WorkOrder"> | string
    description?: StringFilter<"WorkOrder"> | string
    scheduledDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    laborCost?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"WorkOrder"> | string | null
    parkingCharge?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    arrivalDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    quotedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    isHistorical?: BoolFilter<"WorkOrder"> | boolean
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    lineItems?: WorkOrderLineItemListRelationFilter
    logs?: WorkOrderLogListRelationFilter
    assignments?: WorkOrderAssignmentListRelationFilter
  }, "id" | "code">

  export type WorkOrderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    customerId?: SortOrderInput | SortOrder
    vehicleId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    taxes?: SortOrder
    discount?: SortOrder
    totalCost?: SortOrder
    notes?: SortOrderInput | SortOrder
    parkingCharge?: SortOrder
    arrivalDate?: SortOrderInput | SortOrder
    quotedAt?: SortOrderInput | SortOrder
    isHistorical?: SortOrder
    _count?: WorkOrderCountOrderByAggregateInput
    _avg?: WorkOrderAvgOrderByAggregateInput
    _max?: WorkOrderMaxOrderByAggregateInput
    _min?: WorkOrderMinOrderByAggregateInput
    _sum?: WorkOrderSumOrderByAggregateInput
  }

  export type WorkOrderScalarWhereWithAggregatesInput = {
    AND?: WorkOrderScalarWhereWithAggregatesInput | WorkOrderScalarWhereWithAggregatesInput[]
    OR?: WorkOrderScalarWhereWithAggregatesInput[]
    NOT?: WorkOrderScalarWhereWithAggregatesInput | WorkOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkOrder"> | Date | string
    code?: StringWithAggregatesFilter<"WorkOrder"> | string
    customerId?: IntNullableWithAggregatesFilter<"WorkOrder"> | number | null
    vehicleId?: IntWithAggregatesFilter<"WorkOrder"> | number
    status?: StringWithAggregatesFilter<"WorkOrder"> | string
    description?: StringWithAggregatesFilter<"WorkOrder"> | string
    scheduledDate?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    laborCost?: DecimalWithAggregatesFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalWithAggregatesFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalWithAggregatesFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalWithAggregatesFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    parkingCharge?: DecimalWithAggregatesFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    arrivalDate?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    quotedAt?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    isHistorical?: BoolWithAggregatesFilter<"WorkOrder"> | boolean
  }

  export type WorkOrderLineItemWhereInput = {
    AND?: WorkOrderLineItemWhereInput | WorkOrderLineItemWhereInput[]
    OR?: WorkOrderLineItemWhereInput[]
    NOT?: WorkOrderLineItemWhereInput | WorkOrderLineItemWhereInput[]
    id?: IntFilter<"WorkOrderLineItem"> | number
    createdAt?: DateTimeFilter<"WorkOrderLineItem"> | Date | string
    workOrderId?: IntFilter<"WorkOrderLineItem"> | number
    inventoryItemId?: IntNullableFilter<"WorkOrderLineItem"> | number | null
    serviceItemId?: IntNullableFilter<"WorkOrderLineItem"> | number | null
    description?: StringFilter<"WorkOrderLineItem"> | string
    quantity?: IntFilter<"WorkOrderLineItem"> | number
    unitPrice?: DecimalFilter<"WorkOrderLineItem"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"WorkOrderLineItem"> | Decimal | DecimalJsLike | number | string
    workOrder?: XOR<WorkOrderRelationFilter, WorkOrderWhereInput>
    inventoryItem?: XOR<InventoryItemNullableRelationFilter, InventoryItemWhereInput> | null
    serviceItem?: XOR<ServiceItemNullableRelationFilter, ServiceItemWhereInput> | null
  }

  export type WorkOrderLineItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    workOrderId?: SortOrder
    inventoryItemId?: SortOrderInput | SortOrder
    serviceItemId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    workOrder?: WorkOrderOrderByWithRelationInput
    inventoryItem?: InventoryItemOrderByWithRelationInput
    serviceItem?: ServiceItemOrderByWithRelationInput
  }

  export type WorkOrderLineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkOrderLineItemWhereInput | WorkOrderLineItemWhereInput[]
    OR?: WorkOrderLineItemWhereInput[]
    NOT?: WorkOrderLineItemWhereInput | WorkOrderLineItemWhereInput[]
    createdAt?: DateTimeFilter<"WorkOrderLineItem"> | Date | string
    workOrderId?: IntFilter<"WorkOrderLineItem"> | number
    inventoryItemId?: IntNullableFilter<"WorkOrderLineItem"> | number | null
    serviceItemId?: IntNullableFilter<"WorkOrderLineItem"> | number | null
    description?: StringFilter<"WorkOrderLineItem"> | string
    quantity?: IntFilter<"WorkOrderLineItem"> | number
    unitPrice?: DecimalFilter<"WorkOrderLineItem"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"WorkOrderLineItem"> | Decimal | DecimalJsLike | number | string
    workOrder?: XOR<WorkOrderRelationFilter, WorkOrderWhereInput>
    inventoryItem?: XOR<InventoryItemNullableRelationFilter, InventoryItemWhereInput> | null
    serviceItem?: XOR<ServiceItemNullableRelationFilter, ServiceItemWhereInput> | null
  }, "id">

  export type WorkOrderLineItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    workOrderId?: SortOrder
    inventoryItemId?: SortOrderInput | SortOrder
    serviceItemId?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    _count?: WorkOrderLineItemCountOrderByAggregateInput
    _avg?: WorkOrderLineItemAvgOrderByAggregateInput
    _max?: WorkOrderLineItemMaxOrderByAggregateInput
    _min?: WorkOrderLineItemMinOrderByAggregateInput
    _sum?: WorkOrderLineItemSumOrderByAggregateInput
  }

  export type WorkOrderLineItemScalarWhereWithAggregatesInput = {
    AND?: WorkOrderLineItemScalarWhereWithAggregatesInput | WorkOrderLineItemScalarWhereWithAggregatesInput[]
    OR?: WorkOrderLineItemScalarWhereWithAggregatesInput[]
    NOT?: WorkOrderLineItemScalarWhereWithAggregatesInput | WorkOrderLineItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkOrderLineItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkOrderLineItem"> | Date | string
    workOrderId?: IntWithAggregatesFilter<"WorkOrderLineItem"> | number
    inventoryItemId?: IntNullableWithAggregatesFilter<"WorkOrderLineItem"> | number | null
    serviceItemId?: IntNullableWithAggregatesFilter<"WorkOrderLineItem"> | number | null
    description?: StringWithAggregatesFilter<"WorkOrderLineItem"> | string
    quantity?: IntWithAggregatesFilter<"WorkOrderLineItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"WorkOrderLineItem"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"WorkOrderLineItem"> | Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: IntFilter<"InventoryItem"> | number
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    name?: StringFilter<"InventoryItem"> | string
    sku?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    quantityOnHand?: IntFilter<"InventoryItem"> | number
    reorderPoint?: IntFilter<"InventoryItem"> | number
    unitCost?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrderInput | SortOrder
    quantityOnHand?: SortOrder
    reorderPoint?: SortOrder
    unitCost?: SortOrder
    unitPrice?: SortOrder
    lineItems?: WorkOrderLineItemOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sku?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    quantityOnHand?: IntFilter<"InventoryItem"> | number
    reorderPoint?: IntFilter<"InventoryItem"> | number
    unitCost?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemListRelationFilter
  }, "id" | "sku">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrderInput | SortOrder
    quantityOnHand?: SortOrder
    reorderPoint?: SortOrder
    unitCost?: SortOrder
    unitPrice?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    name?: StringWithAggregatesFilter<"InventoryItem"> | string
    sku?: StringWithAggregatesFilter<"InventoryItem"> | string
    description?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    quantityOnHand?: IntWithAggregatesFilter<"InventoryItem"> | number
    reorderPoint?: IntWithAggregatesFilter<"InventoryItem"> | number
    unitCost?: DecimalWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
  }

  export type ServiceItemWhereInput = {
    AND?: ServiceItemWhereInput | ServiceItemWhereInput[]
    OR?: ServiceItemWhereInput[]
    NOT?: ServiceItemWhereInput | ServiceItemWhereInput[]
    id?: IntFilter<"ServiceItem"> | number
    createdAt?: DateTimeFilter<"ServiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceItem"> | Date | string
    name?: StringFilter<"ServiceItem"> | string
    description?: StringNullableFilter<"ServiceItem"> | string | null
    defaultPrice?: DecimalFilter<"ServiceItem"> | Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemListRelationFilter
  }

  export type ServiceItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultPrice?: SortOrder
    lineItems?: WorkOrderLineItemOrderByRelationAggregateInput
  }

  export type ServiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ServiceItemWhereInput | ServiceItemWhereInput[]
    OR?: ServiceItemWhereInput[]
    NOT?: ServiceItemWhereInput | ServiceItemWhereInput[]
    createdAt?: DateTimeFilter<"ServiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceItem"> | Date | string
    description?: StringNullableFilter<"ServiceItem"> | string | null
    defaultPrice?: DecimalFilter<"ServiceItem"> | Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemListRelationFilter
  }, "id" | "name">

  export type ServiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultPrice?: SortOrder
    _count?: ServiceItemCountOrderByAggregateInput
    _avg?: ServiceItemAvgOrderByAggregateInput
    _max?: ServiceItemMaxOrderByAggregateInput
    _min?: ServiceItemMinOrderByAggregateInput
    _sum?: ServiceItemSumOrderByAggregateInput
  }

  export type ServiceItemScalarWhereWithAggregatesInput = {
    AND?: ServiceItemScalarWhereWithAggregatesInput | ServiceItemScalarWhereWithAggregatesInput[]
    OR?: ServiceItemScalarWhereWithAggregatesInput[]
    NOT?: ServiceItemScalarWhereWithAggregatesInput | ServiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ServiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceItem"> | Date | string
    name?: StringWithAggregatesFilter<"ServiceItem"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceItem"> | string | null
    defaultPrice?: DecimalWithAggregatesFilter<"ServiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLogWhereInput = {
    AND?: WorkOrderLogWhereInput | WorkOrderLogWhereInput[]
    OR?: WorkOrderLogWhereInput[]
    NOT?: WorkOrderLogWhereInput | WorkOrderLogWhereInput[]
    id?: IntFilter<"WorkOrderLog"> | number
    timestamp?: DateTimeFilter<"WorkOrderLog"> | Date | string
    workOrderId?: IntFilter<"WorkOrderLog"> | number
    message?: StringFilter<"WorkOrderLog"> | string
    author?: StringNullableFilter<"WorkOrderLog"> | string | null
    category?: StringNullableFilter<"WorkOrderLog"> | string | null
    workOrder?: XOR<WorkOrderRelationFilter, WorkOrderWhereInput>
  }

  export type WorkOrderLogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    workOrderId?: SortOrder
    message?: SortOrder
    author?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    workOrder?: WorkOrderOrderByWithRelationInput
  }

  export type WorkOrderLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkOrderLogWhereInput | WorkOrderLogWhereInput[]
    OR?: WorkOrderLogWhereInput[]
    NOT?: WorkOrderLogWhereInput | WorkOrderLogWhereInput[]
    timestamp?: DateTimeFilter<"WorkOrderLog"> | Date | string
    workOrderId?: IntFilter<"WorkOrderLog"> | number
    message?: StringFilter<"WorkOrderLog"> | string
    author?: StringNullableFilter<"WorkOrderLog"> | string | null
    category?: StringNullableFilter<"WorkOrderLog"> | string | null
    workOrder?: XOR<WorkOrderRelationFilter, WorkOrderWhereInput>
  }, "id">

  export type WorkOrderLogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    workOrderId?: SortOrder
    message?: SortOrder
    author?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    _count?: WorkOrderLogCountOrderByAggregateInput
    _avg?: WorkOrderLogAvgOrderByAggregateInput
    _max?: WorkOrderLogMaxOrderByAggregateInput
    _min?: WorkOrderLogMinOrderByAggregateInput
    _sum?: WorkOrderLogSumOrderByAggregateInput
  }

  export type WorkOrderLogScalarWhereWithAggregatesInput = {
    AND?: WorkOrderLogScalarWhereWithAggregatesInput | WorkOrderLogScalarWhereWithAggregatesInput[]
    OR?: WorkOrderLogScalarWhereWithAggregatesInput[]
    NOT?: WorkOrderLogScalarWhereWithAggregatesInput | WorkOrderLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkOrderLog"> | number
    timestamp?: DateTimeWithAggregatesFilter<"WorkOrderLog"> | Date | string
    workOrderId?: IntWithAggregatesFilter<"WorkOrderLog"> | number
    message?: StringWithAggregatesFilter<"WorkOrderLog"> | string
    author?: StringNullableWithAggregatesFilter<"WorkOrderLog"> | string | null
    category?: StringNullableWithAggregatesFilter<"WorkOrderLog"> | string | null
  }

  export type WorkerWhereInput = {
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    id?: IntFilter<"Worker"> | number
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
    name?: StringFilter<"Worker"> | string
    email?: StringNullableFilter<"Worker"> | string | null
    phone?: StringNullableFilter<"Worker"> | string | null
    commuteExpense?: DecimalFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    shiftExpense?: DecimalFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    mealExpense?: DecimalFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    otherExpense?: DecimalFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    totalJobs?: IntFilter<"Worker"> | number
    totalServices?: IntFilter<"Worker"> | number
    assignments?: WorkOrderAssignmentListRelationFilter
  }

  export type WorkerOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    commuteExpense?: SortOrder
    shiftExpense?: SortOrder
    mealExpense?: SortOrder
    otherExpense?: SortOrder
    totalJobs?: SortOrder
    totalServices?: SortOrder
    assignments?: WorkOrderAssignmentOrderByRelationAggregateInput
  }

  export type WorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
    name?: StringFilter<"Worker"> | string
    email?: StringNullableFilter<"Worker"> | string | null
    phone?: StringNullableFilter<"Worker"> | string | null
    commuteExpense?: DecimalFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    shiftExpense?: DecimalFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    mealExpense?: DecimalFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    otherExpense?: DecimalFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    totalJobs?: IntFilter<"Worker"> | number
    totalServices?: IntFilter<"Worker"> | number
    assignments?: WorkOrderAssignmentListRelationFilter
  }, "id">

  export type WorkerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    commuteExpense?: SortOrder
    shiftExpense?: SortOrder
    mealExpense?: SortOrder
    otherExpense?: SortOrder
    totalJobs?: SortOrder
    totalServices?: SortOrder
    _count?: WorkerCountOrderByAggregateInput
    _avg?: WorkerAvgOrderByAggregateInput
    _max?: WorkerMaxOrderByAggregateInput
    _min?: WorkerMinOrderByAggregateInput
    _sum?: WorkerSumOrderByAggregateInput
  }

  export type WorkerScalarWhereWithAggregatesInput = {
    AND?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    OR?: WorkerScalarWhereWithAggregatesInput[]
    NOT?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Worker"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Worker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Worker"> | Date | string
    name?: StringWithAggregatesFilter<"Worker"> | string
    email?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    commuteExpense?: DecimalWithAggregatesFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    shiftExpense?: DecimalWithAggregatesFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    mealExpense?: DecimalWithAggregatesFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    otherExpense?: DecimalWithAggregatesFilter<"Worker"> | Decimal | DecimalJsLike | number | string
    totalJobs?: IntWithAggregatesFilter<"Worker"> | number
    totalServices?: IntWithAggregatesFilter<"Worker"> | number
  }

  export type WorkOrderAssignmentWhereInput = {
    AND?: WorkOrderAssignmentWhereInput | WorkOrderAssignmentWhereInput[]
    OR?: WorkOrderAssignmentWhereInput[]
    NOT?: WorkOrderAssignmentWhereInput | WorkOrderAssignmentWhereInput[]
    id?: IntFilter<"WorkOrderAssignment"> | number
    createdAt?: DateTimeFilter<"WorkOrderAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrderAssignment"> | Date | string
    workOrderId?: IntFilter<"WorkOrderAssignment"> | number
    workerId?: IntFilter<"WorkOrderAssignment"> | number
    role?: StringNullableFilter<"WorkOrderAssignment"> | string | null
    notes?: StringNullableFilter<"WorkOrderAssignment"> | string | null
    servicesCount?: IntFilter<"WorkOrderAssignment"> | number
    workOrder?: XOR<WorkOrderRelationFilter, WorkOrderWhereInput>
    worker?: XOR<WorkerRelationFilter, WorkerWhereInput>
  }

  export type WorkOrderAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workOrderId?: SortOrder
    workerId?: SortOrder
    role?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    servicesCount?: SortOrder
    workOrder?: WorkOrderOrderByWithRelationInput
    worker?: WorkerOrderByWithRelationInput
  }

  export type WorkOrderAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    workOrderId_workerId?: WorkOrderAssignmentWorkOrderIdWorkerIdCompoundUniqueInput
    AND?: WorkOrderAssignmentWhereInput | WorkOrderAssignmentWhereInput[]
    OR?: WorkOrderAssignmentWhereInput[]
    NOT?: WorkOrderAssignmentWhereInput | WorkOrderAssignmentWhereInput[]
    createdAt?: DateTimeFilter<"WorkOrderAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrderAssignment"> | Date | string
    workOrderId?: IntFilter<"WorkOrderAssignment"> | number
    workerId?: IntFilter<"WorkOrderAssignment"> | number
    role?: StringNullableFilter<"WorkOrderAssignment"> | string | null
    notes?: StringNullableFilter<"WorkOrderAssignment"> | string | null
    servicesCount?: IntFilter<"WorkOrderAssignment"> | number
    workOrder?: XOR<WorkOrderRelationFilter, WorkOrderWhereInput>
    worker?: XOR<WorkerRelationFilter, WorkerWhereInput>
  }, "id" | "workOrderId_workerId">

  export type WorkOrderAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workOrderId?: SortOrder
    workerId?: SortOrder
    role?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    servicesCount?: SortOrder
    _count?: WorkOrderAssignmentCountOrderByAggregateInput
    _avg?: WorkOrderAssignmentAvgOrderByAggregateInput
    _max?: WorkOrderAssignmentMaxOrderByAggregateInput
    _min?: WorkOrderAssignmentMinOrderByAggregateInput
    _sum?: WorkOrderAssignmentSumOrderByAggregateInput
  }

  export type WorkOrderAssignmentScalarWhereWithAggregatesInput = {
    AND?: WorkOrderAssignmentScalarWhereWithAggregatesInput | WorkOrderAssignmentScalarWhereWithAggregatesInput[]
    OR?: WorkOrderAssignmentScalarWhereWithAggregatesInput[]
    NOT?: WorkOrderAssignmentScalarWhereWithAggregatesInput | WorkOrderAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkOrderAssignment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkOrderAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkOrderAssignment"> | Date | string
    workOrderId?: IntWithAggregatesFilter<"WorkOrderAssignment"> | number
    workerId?: IntWithAggregatesFilter<"WorkOrderAssignment"> | number
    role?: StringNullableWithAggregatesFilter<"WorkOrderAssignment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"WorkOrderAssignment"> | string | null
    servicesCount?: IntWithAggregatesFilter<"WorkOrderAssignment"> | number
  }

  export type CustomerCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    company?: string | null
    notes?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    vehicles?: VehicleCreateNestedManyWithoutCustomerInput
    workOrders?: WorkOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    company?: string | null
    notes?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCustomerInput
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    vehicles?: VehicleUpdateManyWithoutCustomerNestedInput
    workOrders?: WorkOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    vehicles?: VehicleUncheckedUpdateManyWithoutCustomerNestedInput
    workOrders?: WorkOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    company?: string | null
    notes?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    vin: string
    make: string
    model: string
    year: number
    licensePlate?: string | null
    mileage?: number | null
    color?: string | null
    engine?: string | null
    notes?: string | null
    customer: CustomerCreateNestedOneWithoutVehiclesInput
    workOrders?: WorkOrderCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: number
    vin: string
    make: string
    model: string
    year: number
    licensePlate?: string | null
    mileage?: number | null
    color?: string | null
    engine?: string | null
    notes?: string | null
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutVehiclesNestedInput
    workOrders?: WorkOrderUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: IntFieldUpdateOperationsInput | number
    vin?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workOrders?: WorkOrderUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: number
    vin: string
    make: string
    model: string
    year: number
    licensePlate?: string | null
    mileage?: number | null
    color?: string | null
    engine?: string | null
    notes?: string | null
  }

  export type VehicleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: IntFieldUpdateOperationsInput | number
    vin?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    customer?: CustomerCreateNestedOneWithoutWorkOrdersInput
    vehicle: VehicleCreateNestedOneWithoutWorkOrdersInput
    lineItems?: WorkOrderLineItemCreateNestedManyWithoutWorkOrderInput
    logs?: WorkOrderLogCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    customerId?: number | null
    vehicleId: number
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    lineItems?: WorkOrderLineItemUncheckedCreateNestedManyWithoutWorkOrderInput
    logs?: WorkOrderLogUncheckedCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentUncheckedCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutWorkOrdersNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutWorkOrdersNestedInput
    lineItems?: WorkOrderLineItemUpdateManyWithoutWorkOrderNestedInput
    logs?: WorkOrderLogUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    lineItems?: WorkOrderLineItemUncheckedUpdateManyWithoutWorkOrderNestedInput
    logs?: WorkOrderLogUncheckedUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUncheckedUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    customerId?: number | null
    vehicleId: number
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
  }

  export type WorkOrderUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkOrderLineItemCreateInput = {
    createdAt?: Date | string
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
    workOrder: WorkOrderCreateNestedOneWithoutLineItemsInput
    inventoryItem?: InventoryItemCreateNestedOneWithoutLineItemsInput
    serviceItem?: ServiceItemCreateNestedOneWithoutLineItemsInput
  }

  export type WorkOrderLineItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    workOrderId: number
    inventoryItemId?: number | null
    serviceItemId?: number | null
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workOrder?: WorkOrderUpdateOneRequiredWithoutLineItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneWithoutLineItemsNestedInput
    serviceItem?: ServiceItemUpdateOneWithoutLineItemsNestedInput
  }

  export type WorkOrderLineItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    inventoryItemId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceItemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    workOrderId: number
    inventoryItemId?: number | null
    serviceItemId?: number | null
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    inventoryItemId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceItemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    sku: string
    description?: string | null
    quantityOnHand?: number
    reorderPoint?: number
    unitCost?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    sku: string
    description?: string | null
    quantityOnHand?: number
    reorderPoint?: number
    unitCost?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    sku: string
    description?: string | null
    quantityOnHand?: number
    reorderPoint?: number
    unitCost?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServiceItemCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    defaultPrice?: Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    defaultPrice?: Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemUncheckedCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineItems?: WorkOrderLineItemUncheckedUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    defaultPrice?: Decimal | DecimalJsLike | number | string
  }

  export type ServiceItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLogCreateInput = {
    timestamp?: Date | string
    message: string
    author?: string | null
    category?: string | null
    workOrder: WorkOrderCreateNestedOneWithoutLogsInput
  }

  export type WorkOrderLogUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    workOrderId: number
    message: string
    author?: string | null
    category?: string | null
  }

  export type WorkOrderLogUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    workOrder?: WorkOrderUpdateOneRequiredWithoutLogsNestedInput
  }

  export type WorkOrderLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderLogCreateManyInput = {
    id?: number
    timestamp?: Date | string
    workOrderId: number
    message: string
    author?: string | null
    category?: string | null
  }

  export type WorkOrderLogUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email?: string | null
    phone?: string | null
    commuteExpense?: Decimal | DecimalJsLike | number | string
    shiftExpense?: Decimal | DecimalJsLike | number | string
    mealExpense?: Decimal | DecimalJsLike | number | string
    otherExpense?: Decimal | DecimalJsLike | number | string
    totalJobs?: number
    totalServices?: number
    assignments?: WorkOrderAssignmentCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email?: string | null
    phone?: string | null
    commuteExpense?: Decimal | DecimalJsLike | number | string
    shiftExpense?: Decimal | DecimalJsLike | number | string
    mealExpense?: Decimal | DecimalJsLike | number | string
    otherExpense?: Decimal | DecimalJsLike | number | string
    totalJobs?: number
    totalServices?: number
    assignments?: WorkOrderAssignmentUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    commuteExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shiftExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mealExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalJobs?: IntFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    assignments?: WorkOrderAssignmentUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    commuteExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shiftExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mealExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalJobs?: IntFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
    assignments?: WorkOrderAssignmentUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email?: string | null
    phone?: string | null
    commuteExpense?: Decimal | DecimalJsLike | number | string
    shiftExpense?: Decimal | DecimalJsLike | number | string
    mealExpense?: Decimal | DecimalJsLike | number | string
    otherExpense?: Decimal | DecimalJsLike | number | string
    totalJobs?: number
    totalServices?: number
  }

  export type WorkerUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    commuteExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shiftExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mealExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalJobs?: IntFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    commuteExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shiftExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mealExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalJobs?: IntFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
  }

  export type WorkOrderAssignmentCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string | null
    notes?: string | null
    servicesCount?: number
    workOrder: WorkOrderCreateNestedOneWithoutAssignmentsInput
    worker: WorkerCreateNestedOneWithoutAssignmentsInput
  }

  export type WorkOrderAssignmentUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workOrderId: number
    workerId: number
    role?: string | null
    notes?: string | null
    servicesCount?: number
  }

  export type WorkOrderAssignmentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
    workOrder?: WorkOrderUpdateOneRequiredWithoutAssignmentsNestedInput
    worker?: WorkerUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type WorkOrderAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    workerId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
  }

  export type WorkOrderAssignmentCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workOrderId: number
    workerId: number
    role?: string | null
    notes?: string | null
    servicesCount?: number
  }

  export type WorkOrderAssignmentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
  }

  export type WorkOrderAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    workerId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type VehicleListRelationFilter = {
    every?: VehicleWhereInput
    some?: VehicleWhereInput
    none?: VehicleWhereInput
  }

  export type WorkOrderListRelationFilter = {
    every?: WorkOrderWhereInput
    some?: WorkOrderWhereInput
    none?: WorkOrderWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    vin?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrder
    mileage?: SortOrder
    color?: SortOrder
    engine?: SortOrder
    notes?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    year?: SortOrder
    mileage?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    vin?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrder
    mileage?: SortOrder
    color?: SortOrder
    engine?: SortOrder
    notes?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    vin?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    licensePlate?: SortOrder
    mileage?: SortOrder
    color?: SortOrder
    engine?: SortOrder
    notes?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    year?: SortOrder
    mileage?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type VehicleRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type WorkOrderLineItemListRelationFilter = {
    every?: WorkOrderLineItemWhereInput
    some?: WorkOrderLineItemWhereInput
    none?: WorkOrderLineItemWhereInput
  }

  export type WorkOrderLogListRelationFilter = {
    every?: WorkOrderLogWhereInput
    some?: WorkOrderLogWhereInput
    none?: WorkOrderLogWhereInput
  }

  export type WorkOrderAssignmentListRelationFilter = {
    every?: WorkOrderAssignmentWhereInput
    some?: WorkOrderAssignmentWhereInput
    none?: WorkOrderAssignmentWhereInput
  }

  export type WorkOrderLineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkOrderLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkOrderAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkOrderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    customerId?: SortOrder
    vehicleId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    taxes?: SortOrder
    discount?: SortOrder
    totalCost?: SortOrder
    notes?: SortOrder
    parkingCharge?: SortOrder
    arrivalDate?: SortOrder
    quotedAt?: SortOrder
    isHistorical?: SortOrder
  }

  export type WorkOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    vehicleId?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    taxes?: SortOrder
    discount?: SortOrder
    totalCost?: SortOrder
    parkingCharge?: SortOrder
  }

  export type WorkOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    customerId?: SortOrder
    vehicleId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    taxes?: SortOrder
    discount?: SortOrder
    totalCost?: SortOrder
    notes?: SortOrder
    parkingCharge?: SortOrder
    arrivalDate?: SortOrder
    quotedAt?: SortOrder
    isHistorical?: SortOrder
  }

  export type WorkOrderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    customerId?: SortOrder
    vehicleId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    taxes?: SortOrder
    discount?: SortOrder
    totalCost?: SortOrder
    notes?: SortOrder
    parkingCharge?: SortOrder
    arrivalDate?: SortOrder
    quotedAt?: SortOrder
    isHistorical?: SortOrder
  }

  export type WorkOrderSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    vehicleId?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    taxes?: SortOrder
    discount?: SortOrder
    totalCost?: SortOrder
    parkingCharge?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type WorkOrderRelationFilter = {
    is?: WorkOrderWhereInput
    isNot?: WorkOrderWhereInput
  }

  export type InventoryItemNullableRelationFilter = {
    is?: InventoryItemWhereInput | null
    isNot?: InventoryItemWhereInput | null
  }

  export type ServiceItemNullableRelationFilter = {
    is?: ServiceItemWhereInput | null
    isNot?: ServiceItemWhereInput | null
  }

  export type WorkOrderLineItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    workOrderId?: SortOrder
    inventoryItemId?: SortOrder
    serviceItemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type WorkOrderLineItemAvgOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    inventoryItemId?: SortOrder
    serviceItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type WorkOrderLineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    workOrderId?: SortOrder
    inventoryItemId?: SortOrder
    serviceItemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type WorkOrderLineItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    workOrderId?: SortOrder
    inventoryItemId?: SortOrder
    serviceItemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type WorkOrderLineItemSumOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    inventoryItemId?: SortOrder
    serviceItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    quantityOnHand?: SortOrder
    reorderPoint?: SortOrder
    unitCost?: SortOrder
    unitPrice?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    id?: SortOrder
    quantityOnHand?: SortOrder
    reorderPoint?: SortOrder
    unitCost?: SortOrder
    unitPrice?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    quantityOnHand?: SortOrder
    reorderPoint?: SortOrder
    unitCost?: SortOrder
    unitPrice?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    quantityOnHand?: SortOrder
    reorderPoint?: SortOrder
    unitCost?: SortOrder
    unitPrice?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    id?: SortOrder
    quantityOnHand?: SortOrder
    reorderPoint?: SortOrder
    unitCost?: SortOrder
    unitPrice?: SortOrder
  }

  export type ServiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultPrice?: SortOrder
  }

  export type ServiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    defaultPrice?: SortOrder
  }

  export type ServiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultPrice?: SortOrder
  }

  export type ServiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultPrice?: SortOrder
  }

  export type ServiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    defaultPrice?: SortOrder
  }

  export type WorkOrderLogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    workOrderId?: SortOrder
    message?: SortOrder
    author?: SortOrder
    category?: SortOrder
  }

  export type WorkOrderLogAvgOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
  }

  export type WorkOrderLogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    workOrderId?: SortOrder
    message?: SortOrder
    author?: SortOrder
    category?: SortOrder
  }

  export type WorkOrderLogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    workOrderId?: SortOrder
    message?: SortOrder
    author?: SortOrder
    category?: SortOrder
  }

  export type WorkOrderLogSumOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
  }

  export type WorkerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    commuteExpense?: SortOrder
    shiftExpense?: SortOrder
    mealExpense?: SortOrder
    otherExpense?: SortOrder
    totalJobs?: SortOrder
    totalServices?: SortOrder
  }

  export type WorkerAvgOrderByAggregateInput = {
    id?: SortOrder
    commuteExpense?: SortOrder
    shiftExpense?: SortOrder
    mealExpense?: SortOrder
    otherExpense?: SortOrder
    totalJobs?: SortOrder
    totalServices?: SortOrder
  }

  export type WorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    commuteExpense?: SortOrder
    shiftExpense?: SortOrder
    mealExpense?: SortOrder
    otherExpense?: SortOrder
    totalJobs?: SortOrder
    totalServices?: SortOrder
  }

  export type WorkerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    commuteExpense?: SortOrder
    shiftExpense?: SortOrder
    mealExpense?: SortOrder
    otherExpense?: SortOrder
    totalJobs?: SortOrder
    totalServices?: SortOrder
  }

  export type WorkerSumOrderByAggregateInput = {
    id?: SortOrder
    commuteExpense?: SortOrder
    shiftExpense?: SortOrder
    mealExpense?: SortOrder
    otherExpense?: SortOrder
    totalJobs?: SortOrder
    totalServices?: SortOrder
  }

  export type WorkerRelationFilter = {
    is?: WorkerWhereInput
    isNot?: WorkerWhereInput
  }

  export type WorkOrderAssignmentWorkOrderIdWorkerIdCompoundUniqueInput = {
    workOrderId: number
    workerId: number
  }

  export type WorkOrderAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workOrderId?: SortOrder
    workerId?: SortOrder
    role?: SortOrder
    notes?: SortOrder
    servicesCount?: SortOrder
  }

  export type WorkOrderAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    workerId?: SortOrder
    servicesCount?: SortOrder
  }

  export type WorkOrderAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workOrderId?: SortOrder
    workerId?: SortOrder
    role?: SortOrder
    notes?: SortOrder
    servicesCount?: SortOrder
  }

  export type WorkOrderAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workOrderId?: SortOrder
    workerId?: SortOrder
    role?: SortOrder
    notes?: SortOrder
    servicesCount?: SortOrder
  }

  export type WorkOrderAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    workOrderId?: SortOrder
    workerId?: SortOrder
    servicesCount?: SortOrder
  }

  export type VehicleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VehicleCreateWithoutCustomerInput, VehicleUncheckedCreateWithoutCustomerInput> | VehicleCreateWithoutCustomerInput[] | VehicleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCustomerInput | VehicleCreateOrConnectWithoutCustomerInput[]
    createMany?: VehicleCreateManyCustomerInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type WorkOrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<WorkOrderCreateWithoutCustomerInput, WorkOrderUncheckedCreateWithoutCustomerInput> | WorkOrderCreateWithoutCustomerInput[] | WorkOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutCustomerInput | WorkOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: WorkOrderCreateManyCustomerInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VehicleCreateWithoutCustomerInput, VehicleUncheckedCreateWithoutCustomerInput> | VehicleCreateWithoutCustomerInput[] | VehicleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCustomerInput | VehicleCreateOrConnectWithoutCustomerInput[]
    createMany?: VehicleCreateManyCustomerInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type WorkOrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<WorkOrderCreateWithoutCustomerInput, WorkOrderUncheckedCreateWithoutCustomerInput> | WorkOrderCreateWithoutCustomerInput[] | WorkOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutCustomerInput | WorkOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: WorkOrderCreateManyCustomerInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type VehicleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VehicleCreateWithoutCustomerInput, VehicleUncheckedCreateWithoutCustomerInput> | VehicleCreateWithoutCustomerInput[] | VehicleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCustomerInput | VehicleCreateOrConnectWithoutCustomerInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutCustomerInput | VehicleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VehicleCreateManyCustomerInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutCustomerInput | VehicleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutCustomerInput | VehicleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type WorkOrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<WorkOrderCreateWithoutCustomerInput, WorkOrderUncheckedCreateWithoutCustomerInput> | WorkOrderCreateWithoutCustomerInput[] | WorkOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutCustomerInput | WorkOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutCustomerInput | WorkOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: WorkOrderCreateManyCustomerInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutCustomerInput | WorkOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutCustomerInput | WorkOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VehicleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VehicleCreateWithoutCustomerInput, VehicleUncheckedCreateWithoutCustomerInput> | VehicleCreateWithoutCustomerInput[] | VehicleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCustomerInput | VehicleCreateOrConnectWithoutCustomerInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutCustomerInput | VehicleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VehicleCreateManyCustomerInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutCustomerInput | VehicleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutCustomerInput | VehicleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type WorkOrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<WorkOrderCreateWithoutCustomerInput, WorkOrderUncheckedCreateWithoutCustomerInput> | WorkOrderCreateWithoutCustomerInput[] | WorkOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutCustomerInput | WorkOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutCustomerInput | WorkOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: WorkOrderCreateManyCustomerInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutCustomerInput | WorkOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutCustomerInput | WorkOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<CustomerCreateWithoutVehiclesInput, CustomerUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutVehiclesInput
    connect?: CustomerWhereUniqueInput
  }

  export type WorkOrderCreateNestedManyWithoutVehicleInput = {
    create?: XOR<WorkOrderCreateWithoutVehicleInput, WorkOrderUncheckedCreateWithoutVehicleInput> | WorkOrderCreateWithoutVehicleInput[] | WorkOrderUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutVehicleInput | WorkOrderCreateOrConnectWithoutVehicleInput[]
    createMany?: WorkOrderCreateManyVehicleInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type WorkOrderUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<WorkOrderCreateWithoutVehicleInput, WorkOrderUncheckedCreateWithoutVehicleInput> | WorkOrderCreateWithoutVehicleInput[] | WorkOrderUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutVehicleInput | WorkOrderCreateOrConnectWithoutVehicleInput[]
    createMany?: WorkOrderCreateManyVehicleInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<CustomerCreateWithoutVehiclesInput, CustomerUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutVehiclesInput
    upsert?: CustomerUpsertWithoutVehiclesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutVehiclesInput, CustomerUpdateWithoutVehiclesInput>, CustomerUncheckedUpdateWithoutVehiclesInput>
  }

  export type WorkOrderUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<WorkOrderCreateWithoutVehicleInput, WorkOrderUncheckedCreateWithoutVehicleInput> | WorkOrderCreateWithoutVehicleInput[] | WorkOrderUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutVehicleInput | WorkOrderCreateOrConnectWithoutVehicleInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutVehicleInput | WorkOrderUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: WorkOrderCreateManyVehicleInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutVehicleInput | WorkOrderUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutVehicleInput | WorkOrderUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type WorkOrderUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<WorkOrderCreateWithoutVehicleInput, WorkOrderUncheckedCreateWithoutVehicleInput> | WorkOrderCreateWithoutVehicleInput[] | WorkOrderUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutVehicleInput | WorkOrderCreateOrConnectWithoutVehicleInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutVehicleInput | WorkOrderUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: WorkOrderCreateManyVehicleInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutVehicleInput | WorkOrderUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutVehicleInput | WorkOrderUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutWorkOrdersInput = {
    create?: XOR<CustomerCreateWithoutWorkOrdersInput, CustomerUncheckedCreateWithoutWorkOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutWorkOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutWorkOrdersInput = {
    create?: XOR<VehicleCreateWithoutWorkOrdersInput, VehicleUncheckedCreateWithoutWorkOrdersInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutWorkOrdersInput
    connect?: VehicleWhereUniqueInput
  }

  export type WorkOrderLineItemCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutWorkOrderInput, WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput> | WorkOrderLineItemCreateWithoutWorkOrderInput[] | WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutWorkOrderInput | WorkOrderLineItemCreateOrConnectWithoutWorkOrderInput[]
    createMany?: WorkOrderLineItemCreateManyWorkOrderInputEnvelope
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
  }

  export type WorkOrderLogCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<WorkOrderLogCreateWithoutWorkOrderInput, WorkOrderLogUncheckedCreateWithoutWorkOrderInput> | WorkOrderLogCreateWithoutWorkOrderInput[] | WorkOrderLogUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderLogCreateOrConnectWithoutWorkOrderInput | WorkOrderLogCreateOrConnectWithoutWorkOrderInput[]
    createMany?: WorkOrderLogCreateManyWorkOrderInputEnvelope
    connect?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
  }

  export type WorkOrderAssignmentCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<WorkOrderAssignmentCreateWithoutWorkOrderInput, WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput> | WorkOrderAssignmentCreateWithoutWorkOrderInput[] | WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderAssignmentCreateOrConnectWithoutWorkOrderInput | WorkOrderAssignmentCreateOrConnectWithoutWorkOrderInput[]
    createMany?: WorkOrderAssignmentCreateManyWorkOrderInputEnvelope
    connect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
  }

  export type WorkOrderLineItemUncheckedCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutWorkOrderInput, WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput> | WorkOrderLineItemCreateWithoutWorkOrderInput[] | WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutWorkOrderInput | WorkOrderLineItemCreateOrConnectWithoutWorkOrderInput[]
    createMany?: WorkOrderLineItemCreateManyWorkOrderInputEnvelope
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
  }

  export type WorkOrderLogUncheckedCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<WorkOrderLogCreateWithoutWorkOrderInput, WorkOrderLogUncheckedCreateWithoutWorkOrderInput> | WorkOrderLogCreateWithoutWorkOrderInput[] | WorkOrderLogUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderLogCreateOrConnectWithoutWorkOrderInput | WorkOrderLogCreateOrConnectWithoutWorkOrderInput[]
    createMany?: WorkOrderLogCreateManyWorkOrderInputEnvelope
    connect?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
  }

  export type WorkOrderAssignmentUncheckedCreateNestedManyWithoutWorkOrderInput = {
    create?: XOR<WorkOrderAssignmentCreateWithoutWorkOrderInput, WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput> | WorkOrderAssignmentCreateWithoutWorkOrderInput[] | WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderAssignmentCreateOrConnectWithoutWorkOrderInput | WorkOrderAssignmentCreateOrConnectWithoutWorkOrderInput[]
    createMany?: WorkOrderAssignmentCreateManyWorkOrderInputEnvelope
    connect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CustomerUpdateOneWithoutWorkOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutWorkOrdersInput, CustomerUncheckedCreateWithoutWorkOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutWorkOrdersInput
    upsert?: CustomerUpsertWithoutWorkOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutWorkOrdersInput, CustomerUpdateWithoutWorkOrdersInput>, CustomerUncheckedUpdateWithoutWorkOrdersInput>
  }

  export type VehicleUpdateOneRequiredWithoutWorkOrdersNestedInput = {
    create?: XOR<VehicleCreateWithoutWorkOrdersInput, VehicleUncheckedCreateWithoutWorkOrdersInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutWorkOrdersInput
    upsert?: VehicleUpsertWithoutWorkOrdersInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutWorkOrdersInput, VehicleUpdateWithoutWorkOrdersInput>, VehicleUncheckedUpdateWithoutWorkOrdersInput>
  }

  export type WorkOrderLineItemUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutWorkOrderInput, WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput> | WorkOrderLineItemCreateWithoutWorkOrderInput[] | WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutWorkOrderInput | WorkOrderLineItemCreateOrConnectWithoutWorkOrderInput[]
    upsert?: WorkOrderLineItemUpsertWithWhereUniqueWithoutWorkOrderInput | WorkOrderLineItemUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: WorkOrderLineItemCreateManyWorkOrderInputEnvelope
    set?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    disconnect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    delete?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    update?: WorkOrderLineItemUpdateWithWhereUniqueWithoutWorkOrderInput | WorkOrderLineItemUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: WorkOrderLineItemUpdateManyWithWhereWithoutWorkOrderInput | WorkOrderLineItemUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: WorkOrderLineItemScalarWhereInput | WorkOrderLineItemScalarWhereInput[]
  }

  export type WorkOrderLogUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<WorkOrderLogCreateWithoutWorkOrderInput, WorkOrderLogUncheckedCreateWithoutWorkOrderInput> | WorkOrderLogCreateWithoutWorkOrderInput[] | WorkOrderLogUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderLogCreateOrConnectWithoutWorkOrderInput | WorkOrderLogCreateOrConnectWithoutWorkOrderInput[]
    upsert?: WorkOrderLogUpsertWithWhereUniqueWithoutWorkOrderInput | WorkOrderLogUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: WorkOrderLogCreateManyWorkOrderInputEnvelope
    set?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
    disconnect?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
    delete?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
    connect?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
    update?: WorkOrderLogUpdateWithWhereUniqueWithoutWorkOrderInput | WorkOrderLogUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: WorkOrderLogUpdateManyWithWhereWithoutWorkOrderInput | WorkOrderLogUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: WorkOrderLogScalarWhereInput | WorkOrderLogScalarWhereInput[]
  }

  export type WorkOrderAssignmentUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<WorkOrderAssignmentCreateWithoutWorkOrderInput, WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput> | WorkOrderAssignmentCreateWithoutWorkOrderInput[] | WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderAssignmentCreateOrConnectWithoutWorkOrderInput | WorkOrderAssignmentCreateOrConnectWithoutWorkOrderInput[]
    upsert?: WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkOrderInput | WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: WorkOrderAssignmentCreateManyWorkOrderInputEnvelope
    set?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    disconnect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    delete?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    connect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    update?: WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkOrderInput | WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: WorkOrderAssignmentUpdateManyWithWhereWithoutWorkOrderInput | WorkOrderAssignmentUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: WorkOrderAssignmentScalarWhereInput | WorkOrderAssignmentScalarWhereInput[]
  }

  export type WorkOrderLineItemUncheckedUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutWorkOrderInput, WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput> | WorkOrderLineItemCreateWithoutWorkOrderInput[] | WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutWorkOrderInput | WorkOrderLineItemCreateOrConnectWithoutWorkOrderInput[]
    upsert?: WorkOrderLineItemUpsertWithWhereUniqueWithoutWorkOrderInput | WorkOrderLineItemUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: WorkOrderLineItemCreateManyWorkOrderInputEnvelope
    set?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    disconnect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    delete?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    update?: WorkOrderLineItemUpdateWithWhereUniqueWithoutWorkOrderInput | WorkOrderLineItemUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: WorkOrderLineItemUpdateManyWithWhereWithoutWorkOrderInput | WorkOrderLineItemUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: WorkOrderLineItemScalarWhereInput | WorkOrderLineItemScalarWhereInput[]
  }

  export type WorkOrderLogUncheckedUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<WorkOrderLogCreateWithoutWorkOrderInput, WorkOrderLogUncheckedCreateWithoutWorkOrderInput> | WorkOrderLogCreateWithoutWorkOrderInput[] | WorkOrderLogUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderLogCreateOrConnectWithoutWorkOrderInput | WorkOrderLogCreateOrConnectWithoutWorkOrderInput[]
    upsert?: WorkOrderLogUpsertWithWhereUniqueWithoutWorkOrderInput | WorkOrderLogUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: WorkOrderLogCreateManyWorkOrderInputEnvelope
    set?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
    disconnect?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
    delete?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
    connect?: WorkOrderLogWhereUniqueInput | WorkOrderLogWhereUniqueInput[]
    update?: WorkOrderLogUpdateWithWhereUniqueWithoutWorkOrderInput | WorkOrderLogUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: WorkOrderLogUpdateManyWithWhereWithoutWorkOrderInput | WorkOrderLogUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: WorkOrderLogScalarWhereInput | WorkOrderLogScalarWhereInput[]
  }

  export type WorkOrderAssignmentUncheckedUpdateManyWithoutWorkOrderNestedInput = {
    create?: XOR<WorkOrderAssignmentCreateWithoutWorkOrderInput, WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput> | WorkOrderAssignmentCreateWithoutWorkOrderInput[] | WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput[]
    connectOrCreate?: WorkOrderAssignmentCreateOrConnectWithoutWorkOrderInput | WorkOrderAssignmentCreateOrConnectWithoutWorkOrderInput[]
    upsert?: WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkOrderInput | WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkOrderInput[]
    createMany?: WorkOrderAssignmentCreateManyWorkOrderInputEnvelope
    set?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    disconnect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    delete?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    connect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    update?: WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkOrderInput | WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkOrderInput[]
    updateMany?: WorkOrderAssignmentUpdateManyWithWhereWithoutWorkOrderInput | WorkOrderAssignmentUpdateManyWithWhereWithoutWorkOrderInput[]
    deleteMany?: WorkOrderAssignmentScalarWhereInput | WorkOrderAssignmentScalarWhereInput[]
  }

  export type WorkOrderCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<WorkOrderCreateWithoutLineItemsInput, WorkOrderUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutLineItemsInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<InventoryItemCreateWithoutLineItemsInput, InventoryItemUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutLineItemsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type ServiceItemCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<ServiceItemCreateWithoutLineItemsInput, ServiceItemUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: ServiceItemCreateOrConnectWithoutLineItemsInput
    connect?: ServiceItemWhereUniqueInput
  }

  export type WorkOrderUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<WorkOrderCreateWithoutLineItemsInput, WorkOrderUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutLineItemsInput
    upsert?: WorkOrderUpsertWithoutLineItemsInput
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutLineItemsInput, WorkOrderUpdateWithoutLineItemsInput>, WorkOrderUncheckedUpdateWithoutLineItemsInput>
  }

  export type InventoryItemUpdateOneWithoutLineItemsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutLineItemsInput, InventoryItemUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutLineItemsInput
    upsert?: InventoryItemUpsertWithoutLineItemsInput
    disconnect?: InventoryItemWhereInput | boolean
    delete?: InventoryItemWhereInput | boolean
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutLineItemsInput, InventoryItemUpdateWithoutLineItemsInput>, InventoryItemUncheckedUpdateWithoutLineItemsInput>
  }

  export type ServiceItemUpdateOneWithoutLineItemsNestedInput = {
    create?: XOR<ServiceItemCreateWithoutLineItemsInput, ServiceItemUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: ServiceItemCreateOrConnectWithoutLineItemsInput
    upsert?: ServiceItemUpsertWithoutLineItemsInput
    disconnect?: ServiceItemWhereInput | boolean
    delete?: ServiceItemWhereInput | boolean
    connect?: ServiceItemWhereUniqueInput
    update?: XOR<XOR<ServiceItemUpdateToOneWithWhereWithoutLineItemsInput, ServiceItemUpdateWithoutLineItemsInput>, ServiceItemUncheckedUpdateWithoutLineItemsInput>
  }

  export type WorkOrderLineItemCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutInventoryItemInput, WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput> | WorkOrderLineItemCreateWithoutInventoryItemInput[] | WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutInventoryItemInput | WorkOrderLineItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: WorkOrderLineItemCreateManyInventoryItemInputEnvelope
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
  }

  export type WorkOrderLineItemUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutInventoryItemInput, WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput> | WorkOrderLineItemCreateWithoutInventoryItemInput[] | WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutInventoryItemInput | WorkOrderLineItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: WorkOrderLineItemCreateManyInventoryItemInputEnvelope
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
  }

  export type WorkOrderLineItemUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutInventoryItemInput, WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput> | WorkOrderLineItemCreateWithoutInventoryItemInput[] | WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutInventoryItemInput | WorkOrderLineItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: WorkOrderLineItemUpsertWithWhereUniqueWithoutInventoryItemInput | WorkOrderLineItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: WorkOrderLineItemCreateManyInventoryItemInputEnvelope
    set?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    disconnect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    delete?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    update?: WorkOrderLineItemUpdateWithWhereUniqueWithoutInventoryItemInput | WorkOrderLineItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: WorkOrderLineItemUpdateManyWithWhereWithoutInventoryItemInput | WorkOrderLineItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: WorkOrderLineItemScalarWhereInput | WorkOrderLineItemScalarWhereInput[]
  }

  export type WorkOrderLineItemUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutInventoryItemInput, WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput> | WorkOrderLineItemCreateWithoutInventoryItemInput[] | WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutInventoryItemInput | WorkOrderLineItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: WorkOrderLineItemUpsertWithWhereUniqueWithoutInventoryItemInput | WorkOrderLineItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: WorkOrderLineItemCreateManyInventoryItemInputEnvelope
    set?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    disconnect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    delete?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    update?: WorkOrderLineItemUpdateWithWhereUniqueWithoutInventoryItemInput | WorkOrderLineItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: WorkOrderLineItemUpdateManyWithWhereWithoutInventoryItemInput | WorkOrderLineItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: WorkOrderLineItemScalarWhereInput | WorkOrderLineItemScalarWhereInput[]
  }

  export type WorkOrderLineItemCreateNestedManyWithoutServiceItemInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutServiceItemInput, WorkOrderLineItemUncheckedCreateWithoutServiceItemInput> | WorkOrderLineItemCreateWithoutServiceItemInput[] | WorkOrderLineItemUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutServiceItemInput | WorkOrderLineItemCreateOrConnectWithoutServiceItemInput[]
    createMany?: WorkOrderLineItemCreateManyServiceItemInputEnvelope
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
  }

  export type WorkOrderLineItemUncheckedCreateNestedManyWithoutServiceItemInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutServiceItemInput, WorkOrderLineItemUncheckedCreateWithoutServiceItemInput> | WorkOrderLineItemCreateWithoutServiceItemInput[] | WorkOrderLineItemUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutServiceItemInput | WorkOrderLineItemCreateOrConnectWithoutServiceItemInput[]
    createMany?: WorkOrderLineItemCreateManyServiceItemInputEnvelope
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
  }

  export type WorkOrderLineItemUpdateManyWithoutServiceItemNestedInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutServiceItemInput, WorkOrderLineItemUncheckedCreateWithoutServiceItemInput> | WorkOrderLineItemCreateWithoutServiceItemInput[] | WorkOrderLineItemUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutServiceItemInput | WorkOrderLineItemCreateOrConnectWithoutServiceItemInput[]
    upsert?: WorkOrderLineItemUpsertWithWhereUniqueWithoutServiceItemInput | WorkOrderLineItemUpsertWithWhereUniqueWithoutServiceItemInput[]
    createMany?: WorkOrderLineItemCreateManyServiceItemInputEnvelope
    set?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    disconnect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    delete?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    update?: WorkOrderLineItemUpdateWithWhereUniqueWithoutServiceItemInput | WorkOrderLineItemUpdateWithWhereUniqueWithoutServiceItemInput[]
    updateMany?: WorkOrderLineItemUpdateManyWithWhereWithoutServiceItemInput | WorkOrderLineItemUpdateManyWithWhereWithoutServiceItemInput[]
    deleteMany?: WorkOrderLineItemScalarWhereInput | WorkOrderLineItemScalarWhereInput[]
  }

  export type WorkOrderLineItemUncheckedUpdateManyWithoutServiceItemNestedInput = {
    create?: XOR<WorkOrderLineItemCreateWithoutServiceItemInput, WorkOrderLineItemUncheckedCreateWithoutServiceItemInput> | WorkOrderLineItemCreateWithoutServiceItemInput[] | WorkOrderLineItemUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: WorkOrderLineItemCreateOrConnectWithoutServiceItemInput | WorkOrderLineItemCreateOrConnectWithoutServiceItemInput[]
    upsert?: WorkOrderLineItemUpsertWithWhereUniqueWithoutServiceItemInput | WorkOrderLineItemUpsertWithWhereUniqueWithoutServiceItemInput[]
    createMany?: WorkOrderLineItemCreateManyServiceItemInputEnvelope
    set?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    disconnect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    delete?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    connect?: WorkOrderLineItemWhereUniqueInput | WorkOrderLineItemWhereUniqueInput[]
    update?: WorkOrderLineItemUpdateWithWhereUniqueWithoutServiceItemInput | WorkOrderLineItemUpdateWithWhereUniqueWithoutServiceItemInput[]
    updateMany?: WorkOrderLineItemUpdateManyWithWhereWithoutServiceItemInput | WorkOrderLineItemUpdateManyWithWhereWithoutServiceItemInput[]
    deleteMany?: WorkOrderLineItemScalarWhereInput | WorkOrderLineItemScalarWhereInput[]
  }

  export type WorkOrderCreateNestedOneWithoutLogsInput = {
    create?: XOR<WorkOrderCreateWithoutLogsInput, WorkOrderUncheckedCreateWithoutLogsInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutLogsInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type WorkOrderUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<WorkOrderCreateWithoutLogsInput, WorkOrderUncheckedCreateWithoutLogsInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutLogsInput
    upsert?: WorkOrderUpsertWithoutLogsInput
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutLogsInput, WorkOrderUpdateWithoutLogsInput>, WorkOrderUncheckedUpdateWithoutLogsInput>
  }

  export type WorkOrderAssignmentCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkOrderAssignmentCreateWithoutWorkerInput, WorkOrderAssignmentUncheckedCreateWithoutWorkerInput> | WorkOrderAssignmentCreateWithoutWorkerInput[] | WorkOrderAssignmentUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkOrderAssignmentCreateOrConnectWithoutWorkerInput | WorkOrderAssignmentCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkOrderAssignmentCreateManyWorkerInputEnvelope
    connect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
  }

  export type WorkOrderAssignmentUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkOrderAssignmentCreateWithoutWorkerInput, WorkOrderAssignmentUncheckedCreateWithoutWorkerInput> | WorkOrderAssignmentCreateWithoutWorkerInput[] | WorkOrderAssignmentUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkOrderAssignmentCreateOrConnectWithoutWorkerInput | WorkOrderAssignmentCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkOrderAssignmentCreateManyWorkerInputEnvelope
    connect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
  }

  export type WorkOrderAssignmentUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkOrderAssignmentCreateWithoutWorkerInput, WorkOrderAssignmentUncheckedCreateWithoutWorkerInput> | WorkOrderAssignmentCreateWithoutWorkerInput[] | WorkOrderAssignmentUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkOrderAssignmentCreateOrConnectWithoutWorkerInput | WorkOrderAssignmentCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkerInput | WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkOrderAssignmentCreateManyWorkerInputEnvelope
    set?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    disconnect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    delete?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    connect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    update?: WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkerInput | WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkOrderAssignmentUpdateManyWithWhereWithoutWorkerInput | WorkOrderAssignmentUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkOrderAssignmentScalarWhereInput | WorkOrderAssignmentScalarWhereInput[]
  }

  export type WorkOrderAssignmentUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkOrderAssignmentCreateWithoutWorkerInput, WorkOrderAssignmentUncheckedCreateWithoutWorkerInput> | WorkOrderAssignmentCreateWithoutWorkerInput[] | WorkOrderAssignmentUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkOrderAssignmentCreateOrConnectWithoutWorkerInput | WorkOrderAssignmentCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkerInput | WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkOrderAssignmentCreateManyWorkerInputEnvelope
    set?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    disconnect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    delete?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    connect?: WorkOrderAssignmentWhereUniqueInput | WorkOrderAssignmentWhereUniqueInput[]
    update?: WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkerInput | WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkOrderAssignmentUpdateManyWithWhereWithoutWorkerInput | WorkOrderAssignmentUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkOrderAssignmentScalarWhereInput | WorkOrderAssignmentScalarWhereInput[]
  }

  export type WorkOrderCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<WorkOrderCreateWithoutAssignmentsInput, WorkOrderUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutAssignmentsInput
    connect?: WorkOrderWhereUniqueInput
  }

  export type WorkerCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<WorkerCreateWithoutAssignmentsInput, WorkerUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutAssignmentsInput
    connect?: WorkerWhereUniqueInput
  }

  export type WorkOrderUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<WorkOrderCreateWithoutAssignmentsInput, WorkOrderUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: WorkOrderCreateOrConnectWithoutAssignmentsInput
    upsert?: WorkOrderUpsertWithoutAssignmentsInput
    connect?: WorkOrderWhereUniqueInput
    update?: XOR<XOR<WorkOrderUpdateToOneWithWhereWithoutAssignmentsInput, WorkOrderUpdateWithoutAssignmentsInput>, WorkOrderUncheckedUpdateWithoutAssignmentsInput>
  }

  export type WorkerUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<WorkerCreateWithoutAssignmentsInput, WorkerUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutAssignmentsInput
    upsert?: WorkerUpsertWithoutAssignmentsInput
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutAssignmentsInput, WorkerUpdateWithoutAssignmentsInput>, WorkerUncheckedUpdateWithoutAssignmentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type VehicleCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    vin: string
    make: string
    model: string
    year: number
    licensePlate?: string | null
    mileage?: number | null
    color?: string | null
    engine?: string | null
    notes?: string | null
    workOrders?: WorkOrderCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutCustomerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vin: string
    make: string
    model: string
    year: number
    licensePlate?: string | null
    mileage?: number | null
    color?: string | null
    engine?: string | null
    notes?: string | null
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutCustomerInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutCustomerInput, VehicleUncheckedCreateWithoutCustomerInput>
  }

  export type VehicleCreateManyCustomerInputEnvelope = {
    data: VehicleCreateManyCustomerInput | VehicleCreateManyCustomerInput[]
  }

  export type WorkOrderCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    vehicle: VehicleCreateNestedOneWithoutWorkOrdersInput
    lineItems?: WorkOrderLineItemCreateNestedManyWithoutWorkOrderInput
    logs?: WorkOrderLogCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutCustomerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    vehicleId: number
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    lineItems?: WorkOrderLineItemUncheckedCreateNestedManyWithoutWorkOrderInput
    logs?: WorkOrderLogUncheckedCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentUncheckedCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutCustomerInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutCustomerInput, WorkOrderUncheckedCreateWithoutCustomerInput>
  }

  export type WorkOrderCreateManyCustomerInputEnvelope = {
    data: WorkOrderCreateManyCustomerInput | WorkOrderCreateManyCustomerInput[]
  }

  export type VehicleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutCustomerInput, VehicleUncheckedUpdateWithoutCustomerInput>
    create: XOR<VehicleCreateWithoutCustomerInput, VehicleUncheckedCreateWithoutCustomerInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutCustomerInput, VehicleUncheckedUpdateWithoutCustomerInput>
  }

  export type VehicleUpdateManyWithWhereWithoutCustomerInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type VehicleScalarWhereInput = {
    AND?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    OR?: VehicleScalarWhereInput[]
    NOT?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    id?: IntFilter<"Vehicle"> | number
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    customerId?: IntFilter<"Vehicle"> | number
    vin?: StringFilter<"Vehicle"> | string
    make?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    licensePlate?: StringNullableFilter<"Vehicle"> | string | null
    mileage?: IntNullableFilter<"Vehicle"> | number | null
    color?: StringNullableFilter<"Vehicle"> | string | null
    engine?: StringNullableFilter<"Vehicle"> | string | null
    notes?: StringNullableFilter<"Vehicle"> | string | null
  }

  export type WorkOrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: WorkOrderWhereUniqueInput
    update: XOR<WorkOrderUpdateWithoutCustomerInput, WorkOrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<WorkOrderCreateWithoutCustomerInput, WorkOrderUncheckedCreateWithoutCustomerInput>
  }

  export type WorkOrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: WorkOrderWhereUniqueInput
    data: XOR<WorkOrderUpdateWithoutCustomerInput, WorkOrderUncheckedUpdateWithoutCustomerInput>
  }

  export type WorkOrderUpdateManyWithWhereWithoutCustomerInput = {
    where: WorkOrderScalarWhereInput
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type WorkOrderScalarWhereInput = {
    AND?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
    OR?: WorkOrderScalarWhereInput[]
    NOT?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
    id?: IntFilter<"WorkOrder"> | number
    createdAt?: DateTimeFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrder"> | Date | string
    code?: StringFilter<"WorkOrder"> | string
    customerId?: IntNullableFilter<"WorkOrder"> | number | null
    vehicleId?: IntFilter<"WorkOrder"> | number
    status?: StringFilter<"WorkOrder"> | string
    description?: StringFilter<"WorkOrder"> | string
    scheduledDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    laborCost?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"WorkOrder"> | string | null
    parkingCharge?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    arrivalDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    quotedAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    isHistorical?: BoolFilter<"WorkOrder"> | boolean
  }

  export type CustomerCreateWithoutVehiclesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    company?: string | null
    notes?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    workOrders?: WorkOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutVehiclesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    company?: string | null
    notes?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    workOrders?: WorkOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutVehiclesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutVehiclesInput, CustomerUncheckedCreateWithoutVehiclesInput>
  }

  export type WorkOrderCreateWithoutVehicleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    customer?: CustomerCreateNestedOneWithoutWorkOrdersInput
    lineItems?: WorkOrderLineItemCreateNestedManyWithoutWorkOrderInput
    logs?: WorkOrderLogCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutVehicleInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    customerId?: number | null
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    lineItems?: WorkOrderLineItemUncheckedCreateNestedManyWithoutWorkOrderInput
    logs?: WorkOrderLogUncheckedCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentUncheckedCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutVehicleInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutVehicleInput, WorkOrderUncheckedCreateWithoutVehicleInput>
  }

  export type WorkOrderCreateManyVehicleInputEnvelope = {
    data: WorkOrderCreateManyVehicleInput | WorkOrderCreateManyVehicleInput[]
  }

  export type CustomerUpsertWithoutVehiclesInput = {
    update: XOR<CustomerUpdateWithoutVehiclesInput, CustomerUncheckedUpdateWithoutVehiclesInput>
    create: XOR<CustomerCreateWithoutVehiclesInput, CustomerUncheckedCreateWithoutVehiclesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutVehiclesInput, CustomerUncheckedUpdateWithoutVehiclesInput>
  }

  export type CustomerUpdateWithoutVehiclesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    workOrders?: WorkOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutVehiclesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    workOrders?: WorkOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type WorkOrderUpsertWithWhereUniqueWithoutVehicleInput = {
    where: WorkOrderWhereUniqueInput
    update: XOR<WorkOrderUpdateWithoutVehicleInput, WorkOrderUncheckedUpdateWithoutVehicleInput>
    create: XOR<WorkOrderCreateWithoutVehicleInput, WorkOrderUncheckedCreateWithoutVehicleInput>
  }

  export type WorkOrderUpdateWithWhereUniqueWithoutVehicleInput = {
    where: WorkOrderWhereUniqueInput
    data: XOR<WorkOrderUpdateWithoutVehicleInput, WorkOrderUncheckedUpdateWithoutVehicleInput>
  }

  export type WorkOrderUpdateManyWithWhereWithoutVehicleInput = {
    where: WorkOrderScalarWhereInput
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyWithoutVehicleInput>
  }

  export type CustomerCreateWithoutWorkOrdersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    company?: string | null
    notes?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    vehicles?: VehicleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutWorkOrdersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    lastName: string
    email?: string | null
    phone: string
    company?: string | null
    notes?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutWorkOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutWorkOrdersInput, CustomerUncheckedCreateWithoutWorkOrdersInput>
  }

  export type VehicleCreateWithoutWorkOrdersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    vin: string
    make: string
    model: string
    year: number
    licensePlate?: string | null
    mileage?: number | null
    color?: string | null
    engine?: string | null
    notes?: string | null
    customer: CustomerCreateNestedOneWithoutVehiclesInput
  }

  export type VehicleUncheckedCreateWithoutWorkOrdersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: number
    vin: string
    make: string
    model: string
    year: number
    licensePlate?: string | null
    mileage?: number | null
    color?: string | null
    engine?: string | null
    notes?: string | null
  }

  export type VehicleCreateOrConnectWithoutWorkOrdersInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutWorkOrdersInput, VehicleUncheckedCreateWithoutWorkOrdersInput>
  }

  export type WorkOrderLineItemCreateWithoutWorkOrderInput = {
    createdAt?: Date | string
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
    inventoryItem?: InventoryItemCreateNestedOneWithoutLineItemsInput
    serviceItem?: ServiceItemCreateNestedOneWithoutLineItemsInput
  }

  export type WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput = {
    id?: number
    createdAt?: Date | string
    inventoryItemId?: number | null
    serviceItemId?: number | null
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemCreateOrConnectWithoutWorkOrderInput = {
    where: WorkOrderLineItemWhereUniqueInput
    create: XOR<WorkOrderLineItemCreateWithoutWorkOrderInput, WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput>
  }

  export type WorkOrderLineItemCreateManyWorkOrderInputEnvelope = {
    data: WorkOrderLineItemCreateManyWorkOrderInput | WorkOrderLineItemCreateManyWorkOrderInput[]
  }

  export type WorkOrderLogCreateWithoutWorkOrderInput = {
    timestamp?: Date | string
    message: string
    author?: string | null
    category?: string | null
  }

  export type WorkOrderLogUncheckedCreateWithoutWorkOrderInput = {
    id?: number
    timestamp?: Date | string
    message: string
    author?: string | null
    category?: string | null
  }

  export type WorkOrderLogCreateOrConnectWithoutWorkOrderInput = {
    where: WorkOrderLogWhereUniqueInput
    create: XOR<WorkOrderLogCreateWithoutWorkOrderInput, WorkOrderLogUncheckedCreateWithoutWorkOrderInput>
  }

  export type WorkOrderLogCreateManyWorkOrderInputEnvelope = {
    data: WorkOrderLogCreateManyWorkOrderInput | WorkOrderLogCreateManyWorkOrderInput[]
  }

  export type WorkOrderAssignmentCreateWithoutWorkOrderInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string | null
    notes?: string | null
    servicesCount?: number
    worker: WorkerCreateNestedOneWithoutAssignmentsInput
  }

  export type WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workerId: number
    role?: string | null
    notes?: string | null
    servicesCount?: number
  }

  export type WorkOrderAssignmentCreateOrConnectWithoutWorkOrderInput = {
    where: WorkOrderAssignmentWhereUniqueInput
    create: XOR<WorkOrderAssignmentCreateWithoutWorkOrderInput, WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput>
  }

  export type WorkOrderAssignmentCreateManyWorkOrderInputEnvelope = {
    data: WorkOrderAssignmentCreateManyWorkOrderInput | WorkOrderAssignmentCreateManyWorkOrderInput[]
  }

  export type CustomerUpsertWithoutWorkOrdersInput = {
    update: XOR<CustomerUpdateWithoutWorkOrdersInput, CustomerUncheckedUpdateWithoutWorkOrdersInput>
    create: XOR<CustomerCreateWithoutWorkOrdersInput, CustomerUncheckedCreateWithoutWorkOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutWorkOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutWorkOrdersInput, CustomerUncheckedUpdateWithoutWorkOrdersInput>
  }

  export type CustomerUpdateWithoutWorkOrdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    vehicles?: VehicleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutWorkOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    vehicles?: VehicleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type VehicleUpsertWithoutWorkOrdersInput = {
    update: XOR<VehicleUpdateWithoutWorkOrdersInput, VehicleUncheckedUpdateWithoutWorkOrdersInput>
    create: XOR<VehicleCreateWithoutWorkOrdersInput, VehicleUncheckedCreateWithoutWorkOrdersInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutWorkOrdersInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutWorkOrdersInput, VehicleUncheckedUpdateWithoutWorkOrdersInput>
  }

  export type VehicleUpdateWithoutWorkOrdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutVehiclesNestedInput
  }

  export type VehicleUncheckedUpdateWithoutWorkOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: IntFieldUpdateOperationsInput | number
    vin?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderLineItemUpsertWithWhereUniqueWithoutWorkOrderInput = {
    where: WorkOrderLineItemWhereUniqueInput
    update: XOR<WorkOrderLineItemUpdateWithoutWorkOrderInput, WorkOrderLineItemUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<WorkOrderLineItemCreateWithoutWorkOrderInput, WorkOrderLineItemUncheckedCreateWithoutWorkOrderInput>
  }

  export type WorkOrderLineItemUpdateWithWhereUniqueWithoutWorkOrderInput = {
    where: WorkOrderLineItemWhereUniqueInput
    data: XOR<WorkOrderLineItemUpdateWithoutWorkOrderInput, WorkOrderLineItemUncheckedUpdateWithoutWorkOrderInput>
  }

  export type WorkOrderLineItemUpdateManyWithWhereWithoutWorkOrderInput = {
    where: WorkOrderLineItemScalarWhereInput
    data: XOR<WorkOrderLineItemUpdateManyMutationInput, WorkOrderLineItemUncheckedUpdateManyWithoutWorkOrderInput>
  }

  export type WorkOrderLineItemScalarWhereInput = {
    AND?: WorkOrderLineItemScalarWhereInput | WorkOrderLineItemScalarWhereInput[]
    OR?: WorkOrderLineItemScalarWhereInput[]
    NOT?: WorkOrderLineItemScalarWhereInput | WorkOrderLineItemScalarWhereInput[]
    id?: IntFilter<"WorkOrderLineItem"> | number
    createdAt?: DateTimeFilter<"WorkOrderLineItem"> | Date | string
    workOrderId?: IntFilter<"WorkOrderLineItem"> | number
    inventoryItemId?: IntNullableFilter<"WorkOrderLineItem"> | number | null
    serviceItemId?: IntNullableFilter<"WorkOrderLineItem"> | number | null
    description?: StringFilter<"WorkOrderLineItem"> | string
    quantity?: IntFilter<"WorkOrderLineItem"> | number
    unitPrice?: DecimalFilter<"WorkOrderLineItem"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"WorkOrderLineItem"> | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLogUpsertWithWhereUniqueWithoutWorkOrderInput = {
    where: WorkOrderLogWhereUniqueInput
    update: XOR<WorkOrderLogUpdateWithoutWorkOrderInput, WorkOrderLogUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<WorkOrderLogCreateWithoutWorkOrderInput, WorkOrderLogUncheckedCreateWithoutWorkOrderInput>
  }

  export type WorkOrderLogUpdateWithWhereUniqueWithoutWorkOrderInput = {
    where: WorkOrderLogWhereUniqueInput
    data: XOR<WorkOrderLogUpdateWithoutWorkOrderInput, WorkOrderLogUncheckedUpdateWithoutWorkOrderInput>
  }

  export type WorkOrderLogUpdateManyWithWhereWithoutWorkOrderInput = {
    where: WorkOrderLogScalarWhereInput
    data: XOR<WorkOrderLogUpdateManyMutationInput, WorkOrderLogUncheckedUpdateManyWithoutWorkOrderInput>
  }

  export type WorkOrderLogScalarWhereInput = {
    AND?: WorkOrderLogScalarWhereInput | WorkOrderLogScalarWhereInput[]
    OR?: WorkOrderLogScalarWhereInput[]
    NOT?: WorkOrderLogScalarWhereInput | WorkOrderLogScalarWhereInput[]
    id?: IntFilter<"WorkOrderLog"> | number
    timestamp?: DateTimeFilter<"WorkOrderLog"> | Date | string
    workOrderId?: IntFilter<"WorkOrderLog"> | number
    message?: StringFilter<"WorkOrderLog"> | string
    author?: StringNullableFilter<"WorkOrderLog"> | string | null
    category?: StringNullableFilter<"WorkOrderLog"> | string | null
  }

  export type WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkOrderInput = {
    where: WorkOrderAssignmentWhereUniqueInput
    update: XOR<WorkOrderAssignmentUpdateWithoutWorkOrderInput, WorkOrderAssignmentUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<WorkOrderAssignmentCreateWithoutWorkOrderInput, WorkOrderAssignmentUncheckedCreateWithoutWorkOrderInput>
  }

  export type WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkOrderInput = {
    where: WorkOrderAssignmentWhereUniqueInput
    data: XOR<WorkOrderAssignmentUpdateWithoutWorkOrderInput, WorkOrderAssignmentUncheckedUpdateWithoutWorkOrderInput>
  }

  export type WorkOrderAssignmentUpdateManyWithWhereWithoutWorkOrderInput = {
    where: WorkOrderAssignmentScalarWhereInput
    data: XOR<WorkOrderAssignmentUpdateManyMutationInput, WorkOrderAssignmentUncheckedUpdateManyWithoutWorkOrderInput>
  }

  export type WorkOrderAssignmentScalarWhereInput = {
    AND?: WorkOrderAssignmentScalarWhereInput | WorkOrderAssignmentScalarWhereInput[]
    OR?: WorkOrderAssignmentScalarWhereInput[]
    NOT?: WorkOrderAssignmentScalarWhereInput | WorkOrderAssignmentScalarWhereInput[]
    id?: IntFilter<"WorkOrderAssignment"> | number
    createdAt?: DateTimeFilter<"WorkOrderAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrderAssignment"> | Date | string
    workOrderId?: IntFilter<"WorkOrderAssignment"> | number
    workerId?: IntFilter<"WorkOrderAssignment"> | number
    role?: StringNullableFilter<"WorkOrderAssignment"> | string | null
    notes?: StringNullableFilter<"WorkOrderAssignment"> | string | null
    servicesCount?: IntFilter<"WorkOrderAssignment"> | number
  }

  export type WorkOrderCreateWithoutLineItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    customer?: CustomerCreateNestedOneWithoutWorkOrdersInput
    vehicle: VehicleCreateNestedOneWithoutWorkOrdersInput
    logs?: WorkOrderLogCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutLineItemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    customerId?: number | null
    vehicleId: number
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    logs?: WorkOrderLogUncheckedCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentUncheckedCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutLineItemsInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutLineItemsInput, WorkOrderUncheckedCreateWithoutLineItemsInput>
  }

  export type InventoryItemCreateWithoutLineItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    sku: string
    description?: string | null
    quantityOnHand?: number
    reorderPoint?: number
    unitCost?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemUncheckedCreateWithoutLineItemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    sku: string
    description?: string | null
    quantityOnHand?: number
    reorderPoint?: number
    unitCost?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemCreateOrConnectWithoutLineItemsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutLineItemsInput, InventoryItemUncheckedCreateWithoutLineItemsInput>
  }

  export type ServiceItemCreateWithoutLineItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    defaultPrice?: Decimal | DecimalJsLike | number | string
  }

  export type ServiceItemUncheckedCreateWithoutLineItemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    description?: string | null
    defaultPrice?: Decimal | DecimalJsLike | number | string
  }

  export type ServiceItemCreateOrConnectWithoutLineItemsInput = {
    where: ServiceItemWhereUniqueInput
    create: XOR<ServiceItemCreateWithoutLineItemsInput, ServiceItemUncheckedCreateWithoutLineItemsInput>
  }

  export type WorkOrderUpsertWithoutLineItemsInput = {
    update: XOR<WorkOrderUpdateWithoutLineItemsInput, WorkOrderUncheckedUpdateWithoutLineItemsInput>
    create: XOR<WorkOrderCreateWithoutLineItemsInput, WorkOrderUncheckedCreateWithoutLineItemsInput>
    where?: WorkOrderWhereInput
  }

  export type WorkOrderUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: WorkOrderWhereInput
    data: XOR<WorkOrderUpdateWithoutLineItemsInput, WorkOrderUncheckedUpdateWithoutLineItemsInput>
  }

  export type WorkOrderUpdateWithoutLineItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutWorkOrdersNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutWorkOrdersNestedInput
    logs?: WorkOrderLogUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutLineItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    logs?: WorkOrderLogUncheckedUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUncheckedUpdateManyWithoutWorkOrderNestedInput
  }

  export type InventoryItemUpsertWithoutLineItemsInput = {
    update: XOR<InventoryItemUpdateWithoutLineItemsInput, InventoryItemUncheckedUpdateWithoutLineItemsInput>
    create: XOR<InventoryItemCreateWithoutLineItemsInput, InventoryItemUncheckedCreateWithoutLineItemsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutLineItemsInput, InventoryItemUncheckedUpdateWithoutLineItemsInput>
  }

  export type InventoryItemUpdateWithoutLineItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemUncheckedUpdateWithoutLineItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServiceItemUpsertWithoutLineItemsInput = {
    update: XOR<ServiceItemUpdateWithoutLineItemsInput, ServiceItemUncheckedUpdateWithoutLineItemsInput>
    create: XOR<ServiceItemCreateWithoutLineItemsInput, ServiceItemUncheckedCreateWithoutLineItemsInput>
    where?: ServiceItemWhereInput
  }

  export type ServiceItemUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: ServiceItemWhereInput
    data: XOR<ServiceItemUpdateWithoutLineItemsInput, ServiceItemUncheckedUpdateWithoutLineItemsInput>
  }

  export type ServiceItemUpdateWithoutLineItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServiceItemUncheckedUpdateWithoutLineItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemCreateWithoutInventoryItemInput = {
    createdAt?: Date | string
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
    workOrder: WorkOrderCreateNestedOneWithoutLineItemsInput
    serviceItem?: ServiceItemCreateNestedOneWithoutLineItemsInput
  }

  export type WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput = {
    id?: number
    createdAt?: Date | string
    workOrderId: number
    serviceItemId?: number | null
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemCreateOrConnectWithoutInventoryItemInput = {
    where: WorkOrderLineItemWhereUniqueInput
    create: XOR<WorkOrderLineItemCreateWithoutInventoryItemInput, WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type WorkOrderLineItemCreateManyInventoryItemInputEnvelope = {
    data: WorkOrderLineItemCreateManyInventoryItemInput | WorkOrderLineItemCreateManyInventoryItemInput[]
  }

  export type WorkOrderLineItemUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: WorkOrderLineItemWhereUniqueInput
    update: XOR<WorkOrderLineItemUpdateWithoutInventoryItemInput, WorkOrderLineItemUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<WorkOrderLineItemCreateWithoutInventoryItemInput, WorkOrderLineItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type WorkOrderLineItemUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: WorkOrderLineItemWhereUniqueInput
    data: XOR<WorkOrderLineItemUpdateWithoutInventoryItemInput, WorkOrderLineItemUncheckedUpdateWithoutInventoryItemInput>
  }

  export type WorkOrderLineItemUpdateManyWithWhereWithoutInventoryItemInput = {
    where: WorkOrderLineItemScalarWhereInput
    data: XOR<WorkOrderLineItemUpdateManyMutationInput, WorkOrderLineItemUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type WorkOrderLineItemCreateWithoutServiceItemInput = {
    createdAt?: Date | string
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
    workOrder: WorkOrderCreateNestedOneWithoutLineItemsInput
    inventoryItem?: InventoryItemCreateNestedOneWithoutLineItemsInput
  }

  export type WorkOrderLineItemUncheckedCreateWithoutServiceItemInput = {
    id?: number
    createdAt?: Date | string
    workOrderId: number
    inventoryItemId?: number | null
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemCreateOrConnectWithoutServiceItemInput = {
    where: WorkOrderLineItemWhereUniqueInput
    create: XOR<WorkOrderLineItemCreateWithoutServiceItemInput, WorkOrderLineItemUncheckedCreateWithoutServiceItemInput>
  }

  export type WorkOrderLineItemCreateManyServiceItemInputEnvelope = {
    data: WorkOrderLineItemCreateManyServiceItemInput | WorkOrderLineItemCreateManyServiceItemInput[]
  }

  export type WorkOrderLineItemUpsertWithWhereUniqueWithoutServiceItemInput = {
    where: WorkOrderLineItemWhereUniqueInput
    update: XOR<WorkOrderLineItemUpdateWithoutServiceItemInput, WorkOrderLineItemUncheckedUpdateWithoutServiceItemInput>
    create: XOR<WorkOrderLineItemCreateWithoutServiceItemInput, WorkOrderLineItemUncheckedCreateWithoutServiceItemInput>
  }

  export type WorkOrderLineItemUpdateWithWhereUniqueWithoutServiceItemInput = {
    where: WorkOrderLineItemWhereUniqueInput
    data: XOR<WorkOrderLineItemUpdateWithoutServiceItemInput, WorkOrderLineItemUncheckedUpdateWithoutServiceItemInput>
  }

  export type WorkOrderLineItemUpdateManyWithWhereWithoutServiceItemInput = {
    where: WorkOrderLineItemScalarWhereInput
    data: XOR<WorkOrderLineItemUpdateManyMutationInput, WorkOrderLineItemUncheckedUpdateManyWithoutServiceItemInput>
  }

  export type WorkOrderCreateWithoutLogsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    customer?: CustomerCreateNestedOneWithoutWorkOrdersInput
    vehicle: VehicleCreateNestedOneWithoutWorkOrdersInput
    lineItems?: WorkOrderLineItemCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutLogsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    customerId?: number | null
    vehicleId: number
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    lineItems?: WorkOrderLineItemUncheckedCreateNestedManyWithoutWorkOrderInput
    assignments?: WorkOrderAssignmentUncheckedCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutLogsInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutLogsInput, WorkOrderUncheckedCreateWithoutLogsInput>
  }

  export type WorkOrderUpsertWithoutLogsInput = {
    update: XOR<WorkOrderUpdateWithoutLogsInput, WorkOrderUncheckedUpdateWithoutLogsInput>
    create: XOR<WorkOrderCreateWithoutLogsInput, WorkOrderUncheckedCreateWithoutLogsInput>
    where?: WorkOrderWhereInput
  }

  export type WorkOrderUpdateToOneWithWhereWithoutLogsInput = {
    where?: WorkOrderWhereInput
    data: XOR<WorkOrderUpdateWithoutLogsInput, WorkOrderUncheckedUpdateWithoutLogsInput>
  }

  export type WorkOrderUpdateWithoutLogsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutWorkOrdersNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutWorkOrdersNestedInput
    lineItems?: WorkOrderLineItemUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    lineItems?: WorkOrderLineItemUncheckedUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUncheckedUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderAssignmentCreateWithoutWorkerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string | null
    notes?: string | null
    servicesCount?: number
    workOrder: WorkOrderCreateNestedOneWithoutAssignmentsInput
  }

  export type WorkOrderAssignmentUncheckedCreateWithoutWorkerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workOrderId: number
    role?: string | null
    notes?: string | null
    servicesCount?: number
  }

  export type WorkOrderAssignmentCreateOrConnectWithoutWorkerInput = {
    where: WorkOrderAssignmentWhereUniqueInput
    create: XOR<WorkOrderAssignmentCreateWithoutWorkerInput, WorkOrderAssignmentUncheckedCreateWithoutWorkerInput>
  }

  export type WorkOrderAssignmentCreateManyWorkerInputEnvelope = {
    data: WorkOrderAssignmentCreateManyWorkerInput | WorkOrderAssignmentCreateManyWorkerInput[]
  }

  export type WorkOrderAssignmentUpsertWithWhereUniqueWithoutWorkerInput = {
    where: WorkOrderAssignmentWhereUniqueInput
    update: XOR<WorkOrderAssignmentUpdateWithoutWorkerInput, WorkOrderAssignmentUncheckedUpdateWithoutWorkerInput>
    create: XOR<WorkOrderAssignmentCreateWithoutWorkerInput, WorkOrderAssignmentUncheckedCreateWithoutWorkerInput>
  }

  export type WorkOrderAssignmentUpdateWithWhereUniqueWithoutWorkerInput = {
    where: WorkOrderAssignmentWhereUniqueInput
    data: XOR<WorkOrderAssignmentUpdateWithoutWorkerInput, WorkOrderAssignmentUncheckedUpdateWithoutWorkerInput>
  }

  export type WorkOrderAssignmentUpdateManyWithWhereWithoutWorkerInput = {
    where: WorkOrderAssignmentScalarWhereInput
    data: XOR<WorkOrderAssignmentUpdateManyMutationInput, WorkOrderAssignmentUncheckedUpdateManyWithoutWorkerInput>
  }

  export type WorkOrderCreateWithoutAssignmentsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    customer?: CustomerCreateNestedOneWithoutWorkOrdersInput
    vehicle: VehicleCreateNestedOneWithoutWorkOrdersInput
    lineItems?: WorkOrderLineItemCreateNestedManyWithoutWorkOrderInput
    logs?: WorkOrderLogCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    customerId?: number | null
    vehicleId: number
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
    lineItems?: WorkOrderLineItemUncheckedCreateNestedManyWithoutWorkOrderInput
    logs?: WorkOrderLogUncheckedCreateNestedManyWithoutWorkOrderInput
  }

  export type WorkOrderCreateOrConnectWithoutAssignmentsInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutAssignmentsInput, WorkOrderUncheckedCreateWithoutAssignmentsInput>
  }

  export type WorkerCreateWithoutAssignmentsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email?: string | null
    phone?: string | null
    commuteExpense?: Decimal | DecimalJsLike | number | string
    shiftExpense?: Decimal | DecimalJsLike | number | string
    mealExpense?: Decimal | DecimalJsLike | number | string
    otherExpense?: Decimal | DecimalJsLike | number | string
    totalJobs?: number
    totalServices?: number
  }

  export type WorkerUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email?: string | null
    phone?: string | null
    commuteExpense?: Decimal | DecimalJsLike | number | string
    shiftExpense?: Decimal | DecimalJsLike | number | string
    mealExpense?: Decimal | DecimalJsLike | number | string
    otherExpense?: Decimal | DecimalJsLike | number | string
    totalJobs?: number
    totalServices?: number
  }

  export type WorkerCreateOrConnectWithoutAssignmentsInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutAssignmentsInput, WorkerUncheckedCreateWithoutAssignmentsInput>
  }

  export type WorkOrderUpsertWithoutAssignmentsInput = {
    update: XOR<WorkOrderUpdateWithoutAssignmentsInput, WorkOrderUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<WorkOrderCreateWithoutAssignmentsInput, WorkOrderUncheckedCreateWithoutAssignmentsInput>
    where?: WorkOrderWhereInput
  }

  export type WorkOrderUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: WorkOrderWhereInput
    data: XOR<WorkOrderUpdateWithoutAssignmentsInput, WorkOrderUncheckedUpdateWithoutAssignmentsInput>
  }

  export type WorkOrderUpdateWithoutAssignmentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutWorkOrdersNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutWorkOrdersNestedInput
    lineItems?: WorkOrderLineItemUpdateManyWithoutWorkOrderNestedInput
    logs?: WorkOrderLogUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    lineItems?: WorkOrderLineItemUncheckedUpdateManyWithoutWorkOrderNestedInput
    logs?: WorkOrderLogUncheckedUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkerUpsertWithoutAssignmentsInput = {
    update: XOR<WorkerUpdateWithoutAssignmentsInput, WorkerUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<WorkerCreateWithoutAssignmentsInput, WorkerUncheckedCreateWithoutAssignmentsInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutAssignmentsInput, WorkerUncheckedUpdateWithoutAssignmentsInput>
  }

  export type WorkerUpdateWithoutAssignmentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    commuteExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shiftExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mealExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalJobs?: IntFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    commuteExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shiftExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mealExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherExpense?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalJobs?: IntFieldUpdateOperationsInput | number
    totalServices?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleCreateManyCustomerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vin: string
    make: string
    model: string
    year: number
    licensePlate?: string | null
    mileage?: number | null
    color?: string | null
    engine?: string | null
    notes?: string | null
  }

  export type WorkOrderCreateManyCustomerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    vehicleId: number
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
  }

  export type VehicleUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workOrders?: WorkOrderUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workOrders?: WorkOrderUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vin?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    vehicle?: VehicleUpdateOneRequiredWithoutWorkOrdersNestedInput
    lineItems?: WorkOrderLineItemUpdateManyWithoutWorkOrderNestedInput
    logs?: WorkOrderLogUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    vehicleId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    lineItems?: WorkOrderLineItemUncheckedUpdateManyWithoutWorkOrderNestedInput
    logs?: WorkOrderLogUncheckedUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUncheckedUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    vehicleId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkOrderCreateManyVehicleInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    customerId?: number | null
    status?: string
    description: string
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    totalCost?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    parkingCharge?: Decimal | DecimalJsLike | number | string
    arrivalDate?: Date | string | null
    quotedAt?: Date | string | null
    isHistorical?: boolean
  }

  export type WorkOrderUpdateWithoutVehicleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutWorkOrdersNestedInput
    lineItems?: WorkOrderLineItemUpdateManyWithoutWorkOrderNestedInput
    logs?: WorkOrderLogUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
    lineItems?: WorkOrderLineItemUncheckedUpdateManyWithoutWorkOrderNestedInput
    logs?: WorkOrderLogUncheckedUpdateManyWithoutWorkOrderNestedInput
    assignments?: WorkOrderAssignmentUncheckedUpdateManyWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateManyWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parkingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    arrivalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHistorical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkOrderLineItemCreateManyWorkOrderInput = {
    id?: number
    createdAt?: Date | string
    inventoryItemId?: number | null
    serviceItemId?: number | null
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLogCreateManyWorkOrderInput = {
    id?: number
    timestamp?: Date | string
    message: string
    author?: string | null
    category?: string | null
  }

  export type WorkOrderAssignmentCreateManyWorkOrderInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workerId: number
    role?: string | null
    notes?: string | null
    servicesCount?: number
  }

  export type WorkOrderLineItemUpdateWithoutWorkOrderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventoryItem?: InventoryItemUpdateOneWithoutLineItemsNestedInput
    serviceItem?: ServiceItemUpdateOneWithoutLineItemsNestedInput
  }

  export type WorkOrderLineItemUncheckedUpdateWithoutWorkOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItemId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceItemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemUncheckedUpdateManyWithoutWorkOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItemId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceItemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLogUpdateWithoutWorkOrderInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderLogUncheckedUpdateWithoutWorkOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderLogUncheckedUpdateManyWithoutWorkOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderAssignmentUpdateWithoutWorkOrderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
    worker?: WorkerUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type WorkOrderAssignmentUncheckedUpdateWithoutWorkOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
  }

  export type WorkOrderAssignmentUncheckedUpdateManyWithoutWorkOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workerId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
  }

  export type WorkOrderLineItemCreateManyInventoryItemInput = {
    id?: number
    createdAt?: Date | string
    workOrderId: number
    serviceItemId?: number | null
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemUpdateWithoutInventoryItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workOrder?: WorkOrderUpdateOneRequiredWithoutLineItemsNestedInput
    serviceItem?: ServiceItemUpdateOneWithoutLineItemsNestedInput
  }

  export type WorkOrderLineItemUncheckedUpdateWithoutInventoryItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    serviceItemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    serviceItemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemCreateManyServiceItemInput = {
    id?: number
    createdAt?: Date | string
    workOrderId: number
    inventoryItemId?: number | null
    description: string
    quantity?: number
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemUpdateWithoutServiceItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workOrder?: WorkOrderUpdateOneRequiredWithoutLineItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneWithoutLineItemsNestedInput
  }

  export type WorkOrderLineItemUncheckedUpdateWithoutServiceItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    inventoryItemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderLineItemUncheckedUpdateManyWithoutServiceItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    inventoryItemId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkOrderAssignmentCreateManyWorkerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workOrderId: number
    role?: string | null
    notes?: string | null
    servicesCount?: number
  }

  export type WorkOrderAssignmentUpdateWithoutWorkerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
    workOrder?: WorkOrderUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type WorkOrderAssignmentUncheckedUpdateWithoutWorkerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
  }

  export type WorkOrderAssignmentUncheckedUpdateManyWithoutWorkerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workOrderId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servicesCount?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleCountOutputTypeDefaultArgs instead
     */
    export type VehicleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkOrderCountOutputTypeDefaultArgs instead
     */
    export type WorkOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryItemCountOutputTypeDefaultArgs instead
     */
    export type InventoryItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceItemCountOutputTypeDefaultArgs instead
     */
    export type ServiceItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerCountOutputTypeDefaultArgs instead
     */
    export type WorkerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleDefaultArgs instead
     */
    export type VehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkOrderDefaultArgs instead
     */
    export type WorkOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkOrderLineItemDefaultArgs instead
     */
    export type WorkOrderLineItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkOrderLineItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryItemDefaultArgs instead
     */
    export type InventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceItemDefaultArgs instead
     */
    export type ServiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkOrderLogDefaultArgs instead
     */
    export type WorkOrderLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkOrderLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerDefaultArgs instead
     */
    export type WorkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkOrderAssignmentDefaultArgs instead
     */
    export type WorkOrderAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkOrderAssignmentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}